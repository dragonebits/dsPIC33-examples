Disassembly Listing for CKABaud081622
Generated From:
C:/Cust_Tests/CKAutoBaud/CKABaud081622.X/dist/default/production/CKABaud081622.X.production.elf
Sep 23, 2022 2:23:41 AM

---  C:/Cust_Tests/CKAutoBaud/CKABaud081622.X/mcc_generated_files/uart2.c  ------------------------------
1:                 /**
2:                   UART2 Generated Driver File 
3:                 
4:                   @Company
5:                     Microchip Technology Inc.
6:                 
7:                   @File Name
8:                     uart2.c
9:                 
10:                  @Summary
11:                    This is the generated source file for the UART2 driver using PIC24 / dsPIC33 / PIC32MM MCUs
12:                
13:                  @Description
14:                    This source file provides APIs for driver for UART2. 
15:                    Generation Information : 
16:                        Product Revision  :  PIC24 / dsPIC33 / PIC32MM MCUs - 1.171.1
17:                        Device            :  dsPIC33CK256MP506
18:                    The generated drivers are tested against the following:
19:                        Compiler          :  XC16 v1.70
20:                        MPLAB             :  MPLAB X v5.50
21:                */
22:                
23:                /*
24:                    (c) 2020 Microchip Technology Inc. and its subsidiaries. You may use this
25:                    software and any derivatives exclusively with Microchip products.
26:                
27:                    THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
28:                    EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
29:                    WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
30:                    PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP PRODUCTS, COMBINATION
31:                    WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
32:                
33:                    IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
34:                    INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
35:                    WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
36:                    BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
37:                    FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
38:                    ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
39:                    THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
40:                
41:                    MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE
42:                    TERMS.
43:                */
44:                
45:                /**
46:                  Section: Included Files
47:                */
48:                #include <stdbool.h>
49:                #include <stdint.h>
50:                #include <stddef.h>
51:                #include "xc.h"
52:                #include "uart2.h"
53:                
54:                /**
55:                  Section: Data Type Definitions
56:                */
57:                
58:                /** UART Driver Queue Status
59:                
60:                  @Summary
61:                    Defines the object required for the status of the queue.
62:                */
63:                
64:                static uint8_t * volatile rxTail;
65:                static uint8_t *rxHead;
66:                static uint8_t *txTail;
67:                static uint8_t * volatile txHead;
68:                static bool volatile rxOverflowed;
69:                
70:                /** UART Driver Queue Length
71:                
72:                  @Summary
73:                    Defines the length of the Transmit and Receive Buffers
74:                
75:                */
76:                
77:                /* We add one extra byte than requested so that we don't have to have a separate
78:                 * bit to determine the difference between buffer full and buffer empty, but
79:                 * still be able to hold the amount of data requested by the user.  Empty is
80:                 * when head == tail.  So full will result in head/tail being off by one due to
81:                 * the extra byte.
82:                 */
83:                #define UART2_CONFIG_TX_BYTEQ_LENGTH (8+1)
84:                #define UART2_CONFIG_RX_BYTEQ_LENGTH (8+1)
85:                
86:                /** UART Driver Queue
87:                
88:                  @Summary
89:                    Defines the Transmit and Receive Buffers
90:                
91:                */
92:                
93:                static uint8_t txQueue[UART2_CONFIG_TX_BYTEQ_LENGTH];
94:                static uint8_t rxQueue[UART2_CONFIG_RX_BYTEQ_LENGTH];
95:                
96:                void (*UART2_TxDefaultInterruptHandler)(void);
97:                void (*UART2_RxDefaultInterruptHandler)(void);
98:                
99:                /**
100:                 Section: Driver Interface
101:               */
102:               
103:               void UART2_Initialize(void)
104:               {
105:                   IEC1bits.U2TXIE = 0;
0007BE  A98823     BCLR 0x823, #4
106:                   IEC1bits.U2RXIE = 0;
0007C0  A96823     BCLR 0x823, #3
107:                   IEC11bits.U2EVTIE = 0; //disable UART2 event interrupt
0007C2  A9C837     BCLR 0x837, #6
108:               
109:                   // URXEN disabled; RXBIMD RXBKIF flag when Break makes low-to-high transition after being low for at least 23/11 bit periods; UARTEN enabled; MOD Asynchronous 8-bit UART; UTXBRK disabled; BRKOVR TX line driven by shifter; UTXEN disabled; USIDL disabled; WAKE disabled; ABAUD disabled; BRGH enabled; 
110:                   // Data Bits = 8; Parity = None; Stop Bits = 1 Stop bit sent, 1 checked at RX;
111:                   U2MODE = (0x8080 & ~(1<<15));  // disabling UART ON bit
0007C4  200800     MOV #0x80, W0
0007C6  881300     MOV W0, U2MODE
112:                   // STSEL 1 Stop bit sent, 1 checked at RX; BCLKMOD disabled; SLPEN disabled; FLO Off; BCLKSEL FOSC/2; C0EN disabled; RUNOVF disabled; UTXINV disabled; URXINV disabled; HALFDPLX disabled; 
113:                   U2MODEH = 0x00;
0007C8  EF2262     CLR U2MODEH
114:                   // OERIE disabled; RXBKIF disabled; RXBKIE enabled; ABDOVF disabled; OERR disabled; TXCIE disabled; TXCIF disabled; FERIE disabled; TXMTIE disabled; ABDOVE disabled; CERIE disabled; CERIF disabled; PERIE disabled; 
115:                   U2STA = 0x400;
0007CA  204000     MOV #0x400, W0
0007CC  881320     MOV W0, U2STA
116:                   // URXISEL RX_ONE_WORD; UTXBE enabled; UTXISEL TX_BUF_EMPTY; URXBE enabled; STPMD disabled; TXWRE disabled; 
117:                   U2STAH = 0x22;
0007CE  200220     MOV #0x22, W0
0007D0  881330     MOV W0, U2STAH
118:                   // BaudRate = 115200; Frequency = 100000000 Hz; BRG 216; 
119:                   U2BRG = 0xD8;
0007D2  200D80     MOV #0xD8, W0
0007D4  881340     MOV W0, U2BRG
120:                   // BRG 0; 
121:                   U2BRGH = 0x00;
0007D6  EF226A     CLR U2BRGH
122:                   // P1 0; 
123:                   U2P1 = 0x00;
0007D8  EF2274     CLR U2P1
124:                   // P2 0; 
125:                   U2P2 = 0x00;
0007DA  EF2276     CLR U2P2
126:                   // P3 0; 
127:                   U2P3 = 0x00;
0007DC  EF2278     CLR U2P3
128:                   // P3H 0; 
129:                   U2P3H = 0x00;
0007DE  EF227A     CLR U2P3H
130:                   // TXCHK 0; 
131:                   U2TXCHK = 0x00;
0007E0  EF227C     CLR U2TXCHK
132:                   // RXCHK 0; 
133:                   U2RXCHK = 0x00;
0007E2  EF227E     CLR U2RXCHK
134:                   // T0PD 1 ETU; PTRCL disabled; TXRPT Retransmit the error byte once; CONV Direct logic; 
135:                   U2SCCON = 0x00;
0007E4  EF2280     CLR U2SCCON
136:                   // TXRPTIF disabled; TXRPTIE disabled; WTCIF disabled; WTCIE disabled; BTCIE disabled; BTCIF disabled; GTCIF disabled; GTCIE disabled; RXRPTIE disabled; RXRPTIF disabled; 
137:                   U2SCINT = 0x00;
0007E6  EF2282     CLR U2SCINT
138:                   // ABDIF disabled; WUIF disabled; ABDIE disabled; 
139:                   U2INT = 0x00;
0007E8  EF2284     CLR U2INT
140:                   
141:                   txHead = txQueue;
0007EA  2103B0     MOV #0x103B, W0
0007EC  888040     MOV W0, txHead
142:                   txTail = txQueue;
0007EE  888050     MOV W0, txTail
143:                   rxHead = rxQueue;
0007F0  210320     MOV #0x1032, W0
0007F2  888020     MOV W0, rxHead
144:                   rxTail = rxQueue;
0007F4  888030     MOV W0, rxTail
145:                  
146:                   rxOverflowed = false;
0007F6  EF700C     CLR.B rxOverflowed
147:               
148:                   UART2_SetTxInterruptHandler(&UART2_Transmit_CallBack);
0007F8  207640     MOV #0x764, W0
0007FA  07FFD3     RCALL UART2_SetTxInterruptHandler
149:               
150:                   UART2_SetRxInterruptHandler(&UART2_Receive_CallBack);
0007FC  209860     MOV #0x986, W0
0007FE  07FFD8     RCALL UART2_SetRxInterruptHandler
151:               
152:                   IEC1bits.U2RXIE = 1;
000800  A86823     BSET 0x823, #3
153:                   IEC11bits.U2EVTIE = 1; //enable UART2 event interrupt
000802  A8C837     BSET 0x837, #6
154:                   
155:                   //Make sure to set LAT bit corresponding to TxPin as high before UART initialization
156:                   U2MODEbits.UARTEN = 1;   // enabling UART ON bit
000804  A8E261     BSET 0x261, #7
157:                   U2MODEbits.UTXEN = 1;
000806  A8A260     BSET U2MODE, #5
158:                   U2MODEbits.URXEN = 1;
000808  A88260     BSET U2MODE, #4
159:               }
00080A  060000     RETURN
160:               
161:               /**
162:                   Maintains the driver's transmitter state machine and implements its ISR
163:               */
164:               
165:               void UART2_SetTxInterruptHandler(void (* interruptHandler)(void))
166:               {
167:                   if(interruptHandler == NULL)
0007A2  E00000     CP0 W0
0007A4  3A0003     BRA NZ, .L14
168:                   {
169:                       UART2_TxDefaultInterruptHandler = &UART2_Transmit_CallBack;
0007A6  207640     MOV #0x764, W0
0007A8  888000     MOV W0, UART2_TxDefaultInterruptHandler
0007AA  370001     BRA .L13
170:                   }
171:                   else
172:                   {
173:                       UART2_TxDefaultInterruptHandler = interruptHandler;
0007AC  888000     MOV W0, UART2_TxDefaultInterruptHandler
174:                   }
175:               } 
0007AE  060000     RETURN
176:               
177:               
178:               void __attribute__ ( ( interrupt, no_auto_psv ) ) _U2TXInterrupt ( void )
179:               {
0003E8  F80036     PUSH RCOUNT
0003EA  BE9F80     MOV.D W0, [W15++]
0003EC  BE9F82     MOV.D W2, [W15++]
0003EE  BE9F84     MOV.D W4, [W15++]
0003F0  BE9F86     MOV.D W6, [W15++]
180:                   if(UART2_TxDefaultInterruptHandler)
0003F2  808000     MOV UART2_TxDefaultInterruptHandler, W0
0003F4  E00000     CP0 W0
0003F6  320001     BRA Z, .L17
181:                   {
182:                       UART2_TxDefaultInterruptHandler();
0003F8  010000     CALL W0
183:                   }
184:                   
185:                   if(txHead == txTail)
0003FA  808052     MOV txTail, W2
0003FC  808040     MOV txHead, W0
0003FE  500F82     SUB W0, W2, [W15]
000400  3A0002     BRA NZ, .L18
186:                   {
187:                       IEC1bits.U2TXIE = 0;
000402  A98823     BCLR 0x823, #4
000404  370011     BRA .L16
188:                   }
189:                   else
190:                   {
191:                       IFS1bits.U2TXIF = 0;
000406  A98803     BCLR 0x803, #4
192:               
193:                       while(!(U2STAHbits.UTXBF == 1))
00040C  37000B     BRA .L20
000424  AB8266     BTST U2STAH, #4
000426  32FFF3     BRA Z, .L22
194:                       {
195:                           U2TXREG = *txHead++;
00040E  808040     MOV txHead, W0
000410  FB80B0     ZE [W0++], W1
000412  881381     MOV W1, U2TXREG
000414  888040     MOV W0, txHead
196:               
197:                           if(txHead == (txQueue + UART2_CONFIG_TX_BYTEQ_LENGTH))
000408  210443     MOV #0x1044, W3
000416  808040     MOV txHead, W0
000418  500F83     SUB W0, W3, [W15]
00041A  3A0001     BRA NZ, .L21
198:                           {
199:                               txHead = txQueue;
00040A  2103B4     MOV #0x103B, W4
00041C  888044     MOV W4, txHead
200:                           }
201:               
202:                           // Are we empty?
203:                           if(txHead == txTail)
00041E  808040     MOV txHead, W0
000420  500F82     SUB W0, W2, [W15]
000422  320002     BRA Z, .L16
204:                           {
205:                               break;
206:                           }
207:                       }
208:                   }
209:               }
000428  BE034F     MOV.D [--W15], W6
00042A  BE024F     MOV.D [--W15], W4
00042C  BE014F     MOV.D [--W15], W2
00042E  BE004F     MOV.D [--W15], W0
000430  F90036     POP RCOUNT
000432  064000     RETFIE
210:               
211:               void __attribute__ ((weak)) UART2_Transmit_CallBack ( void )
212:               { 
213:               
214:               }
000764  060000     RETURN
215:               
216:               void UART2_SetRxInterruptHandler(void (* interruptHandler)(void))
217:               {
218:                   if(interruptHandler == NULL)
0007B0  E00000     CP0 W0
0007B2  3A0003     BRA NZ, .L24
219:                   {
220:                       UART2_RxDefaultInterruptHandler = &UART2_Receive_CallBack;
0007B4  209860     MOV #0x986, W0
0007B6  888010     MOV W0, UART2_RxDefaultInterruptHandler
0007B8  370001     BRA .L23
221:                   }
222:                   else
223:                   {
224:                       UART2_RxDefaultInterruptHandler = interruptHandler;
0007BA  888010     MOV W0, UART2_RxDefaultInterruptHandler
225:                   }
226:               }
0007BC  060000     RETURN
227:               
228:               void __attribute__ ( ( interrupt, no_auto_psv ) ) _U2RXInterrupt( void )
229:               {
000434  F80036     PUSH RCOUNT
000436  BE9F80     MOV.D W0, [W15++]
000438  BE9F82     MOV.D W2, [W15++]
00043A  BE9F84     MOV.D W4, [W15++]
00043C  BE9F86     MOV.D W6, [W15++]
230:                   if(UART2_RxDefaultInterruptHandler)
00043E  808010     MOV UART2_RxDefaultInterruptHandler, W0
000440  E00000     CP0 W0
000442  320001     BRA Z, .L28
231:                   {
232:                       UART2_RxDefaultInterruptHandler();
000444  010000     CALL W0
233:                   }
234:                   
235:                   IFS1bits.U2RXIF = 0;
000446  A96803     BCLR 0x803, #3
236:               
237:                   while(!(U2STAHbits.URXBE == 1))
000450  370014     BRA .L34
00047A  AB2266     BTST U2STAH, #1
00047C  32FFEA     BRA Z, .L33
238:                   {
239:                       *rxTail = U2RXREG;
000452  808030     MOV rxTail, W0
000454  801361     MOV U2RXREG, W1
000456  784801     MOV.B W1, [W0]
240:               
241:                       // Will the increment not result in a wrap and not result in a pure collision?
242:                       // This is most often condition so check first
243:                       if ( ( rxTail    != (rxQueue + UART2_CONFIG_RX_BYTEQ_LENGTH-1)) &&
00044A  2103A2     MOV #0x103A, W2
000458  808030     MOV rxTail, W0
00045A  500F82     SUB W0, W2, [W15]
00045C  320005     BRA Z, .L30
000460  518F80     SUB W3, W0, [W15]
000462  320002     BRA Z, .L30
244:                            ((rxTail+1) != rxHead) )
000448  808023     MOV rxHead, W3
00045E  EC1006     INC rxTail, WREG
245:                       {
246:                           rxTail++;
000464  EC3006     INC rxTail
000466  370009     BRA .L34
247:                       } 
248:                       else if ( (rxTail == (rxQueue + UART2_CONFIG_RX_BYTEQ_LENGTH-1)) &&
00044E  210325     MOV #0x1032, W5
000468  808031     MOV rxTail, W1
00046A  508F82     SUB W1, W2, [W15]
00046C  3A0004     BRA NZ, .L32
00046E  518F85     SUB W3, W5, [W15]
000470  320002     BRA Z, .L32
249:                                 (rxHead !=  rxQueue) )
250:                       {
251:                           // Pure wrap no collision
252:                           rxTail = rxQueue;
000472  888035     MOV W5, rxTail
000474  370002     BRA .L34
253:                       } 
254:                       else // must be collision
255:                       {
256:                           rxOverflowed = true;
00044C  B3C014     MOV.B #0x1, W4
000476  2100C0     MOV #0x100C, W0
000478  784804     MOV.B W4, [W0]
257:                       }
258:                   }
259:               }
00047E  BE034F     MOV.D [--W15], W6
000480  BE024F     MOV.D [--W15], W4
000482  BE014F     MOV.D [--W15], W2
000484  BE004F     MOV.D [--W15], W0
000486  F90036     POP RCOUNT
000488  064000     RETFIE
260:               
261:               void __attribute__ ((weak)) UART2_Receive_CallBack(void)
262:               {
263:               
264:               }
000766  060000     RETURN
265:               
266:               void __attribute__ ( ( interrupt, no_auto_psv ) ) _U2EInterrupt ( void )
267:               {
268:                   if ((U2STAbits.OERR == 1))
00048A  AB2264     BTST U2STA, #1
00048C  320001     BRA Z, .L36
269:                   {
270:                       U2STAbits.OERR = 0;
00048E  A92264     BCLR U2STA, #1
271:                   }
272:                   
273:                   IFS3bits.U2EIF = 0;
000490  A94806     BCLR IFS3, #2
274:               }
000492  064000     RETFIE
275:               
276:               /* ISR for UART Event Interrupt */
277:               
278:               void __attribute__ ( ( interrupt, no_auto_psv ) ) _U2EVTInterrupt ( void )
279:               {
000494  BE9F80     MOV.D W0, [W15++]
280:                   /* Add handling for UART events here */
281:               
282:                   IFS11bits.U2EVTIF = false;
000496  A9C817     BCLR 0x817, #6
283:                   if (U2STAbits.RXBKIF) U2STAbits.RXBKIF = 0;
000498  AB4264     BTST U2STA, #2
00049A  320001     BRA Z, .L38
00049C  A94264     BCLR U2STA, #2
284:                   U2MODEbits.ABAUD = 1;
00049E  A8C260     BSET U2MODE, #6
285:                   _LATC12 = U2MODEbits.ABAUD;
0004A0  0AA066     BFEXT #0x6, #0x1, U2MODE, W0
0004A2  000260     NOP
0004A4  DD004C     SL W0, #12, W0
0004A6  8071F1     MOV LATC, W1
0004A8  A1C001     BCLR W1, #12
0004AA  700081     IOR W0, W1, W1
0004AC  8871F1     MOV W1, LATC
286:               }
0004AE  BE004F     MOV.D [--W15], W0
0004B0  064000     RETFIE
287:               
288:               /**
289:                 Section: UART Driver Client Routines
290:               */
291:               
292:               uint8_t UART2_Read( void)
293:               {
294:                   uint8_t data = 0;
295:               
296:                   while (rxHead == rxTail )
00080C  808020     MOV rxHead, W0
00080E  E31006     CP rxTail
000810  32FFFE     BRA Z, .L40
297:                   {
298:                   }
299:                   
300:                   data = *rxHead;
000812  7840B0     MOV.B [W0++], W1
301:               
302:                   rxHead++;
000814  888020     MOV W0, rxHead
303:               
304:                   if (rxHead == (rxQueue + UART2_CONFIG_RX_BYTEQ_LENGTH))
000816  2103B2     MOV #0x103B, W2
000818  500F82     SUB W0, W2, [W15]
00081A  3A0002     BRA NZ, .L41
305:                   {
306:                       rxHead = rxQueue;
00081C  210320     MOV #0x1032, W0
00081E  888020     MOV W0, rxHead
307:                   }
308:                   return data;
309:               }
000820  784001     MOV.B W1, W0
000822  060000     RETURN
310:               
311:               void UART2_Write( uint8_t byte)
312:               {
00084E  781F88     MOV W8, [W15++]
000850  784400     MOV.B W0, W8
313:                   while(UART2_IsTxReady() == 0)
000852  07FFEF     RCALL UART2_IsTxReady
000854  E00400     CP0.B W0
000856  32FFFD     BRA Z, .L48
314:                   {
315:                   }
316:               
317:                   *txTail = byte;
000858  808050     MOV txTail, W0
00085A  785808     MOV.B W8, [W0++]
318:               
319:                   txTail++;
00085C  888050     MOV W0, txTail
320:                   
321:                   if (txTail == (txQueue + UART2_CONFIG_TX_BYTEQ_LENGTH))
00085E  210441     MOV #0x1044, W1
000860  500F81     SUB W0, W1, [W15]
000862  3A0002     BRA NZ, .L49
322:                   {
323:                       txTail = txQueue;
000864  2103B0     MOV #0x103B, W0
000866  888050     MOV W0, txTail
324:                   }
325:               
326:                   IEC1bits.U2TXIE = 1;
000868  A88823     BSET 0x823, #4
327:               }
00086A  78044F     MOV [--W15], W8
00086C  060000     RETURN
328:               
329:               bool UART2_IsRxReady(void)
330:               {    
331:                   return !(rxHead == rxTail);
000824  808030     MOV rxTail, W0
000826  B69004     XOR rxHead, WREG
000828  A7F000     BTSC W0, #15
00082A  EA0000     NEG W0, W0
00082C  EA0000     NEG W0, W0
00082E  DE004F     LSR W0, #15, W0
332:               }
000830  060000     RETURN
333:               
334:               bool UART2_IsTxReady(void)
335:               {
336:                   uint16_t size;
337:                   uint8_t *snapshot_txHead = (uint8_t*)txHead;
000832  808041     MOV txHead, W1
338:                   
339:                   if (txTail < snapshot_txHead)
000834  808050     MOV txTail, W0
000836  508F80     SUB W1, W0, [W15]
000838  360003     BRA LEU, .L45
340:                   {
341:                       size = (snapshot_txHead - txTail - 1);
00083A  508000     SUB W1, W0, W0
00083C  E90000     DEC W0, W0
00083E  370002     BRA .L46
342:                   }
343:                   else
344:                   {
345:                       size = ( UART2_CONFIG_TX_BYTEQ_LENGTH - (txTail - snapshot_txHead) - 1 );
000840  508000     SUB W1, W0, W0
000842  400068     ADD W0, #0x8, W0
346:                   }
347:                   
348:                   return (size != 0);
000844  A7F000     BTSC W0, #15
000846  EA0000     NEG W0, W0
000848  EA0000     NEG W0, W0
00084A  DE004F     LSR W0, #15, W0
349:               }
00084C  060000     RETURN
350:               
351:               bool UART2_IsTxDone(void)
352:               {
353:                   if(txTail == txHead)
000870  808051     MOV txTail, W1
000872  808042     MOV txHead, W2
000874  510F81     SUB W2, W1, [W15]
000876  3A0004     BRA NZ, .L52
354:                   {
355:                       return (bool)U2STAbits.TRMT;
000878  200800     MOV #0x80, W0
00087A  B60264     AND U2STA, WREG
00087C  EA0000     NEG W0, W0
00087E  DE004F     LSR W0, #15, W0
356:                   }
357:                   
358:                   return false;
00086E  EB4000     CLR.B W0
359:               }
000880  060000     RETURN
360:               
361:               
362:               /*******************************************************************************
363:               
364:                 !!! Deprecated API !!!
365:                 !!! These functions will not be supported in future releases !!!
366:               
367:               *******************************************************************************/
368:               
369:               static uint8_t UART2_RxDataAvailable(void)
370:               {
371:                   uint16_t size;
372:                   uint8_t *snapshot_rxTail = (uint8_t*)rxTail;
000768  808031     MOV rxTail, W1
373:                   
374:                   if (snapshot_rxTail < rxHead) 
00076A  808020     MOV rxHead, W0
00076C  508F80     SUB W1, W0, [W15]
00076E  310003     BRA C, .L4
375:                   {
376:                       size = ( UART2_CONFIG_RX_BYTEQ_LENGTH - (rxHead-snapshot_rxTail));
000770  508080     SUB W1, W0, W1
000772  4080E9     ADD W1, #0x9, W1
000774  370001     BRA .L5
377:                   }
378:                   else
379:                   {
380:                       size = ( (snapshot_rxTail - rxHead));
000776  508080     SUB W1, W0, W1
381:                   }
382:                   
383:                   if(size > 0xFF)
00077A  200FF2     MOV #0xFF, W2
00077C  508F82     SUB W1, W2, [W15]
00077E  3E0001     BRA GTU, .L6
384:                   {
385:                       return 0xFF;
000778  EBC000     SETM.B W0
386:                   }
387:                   
388:                   return size;
000780  784001     MOV.B W1, W0
389:               }
000782  060000     RETURN
390:               
391:               static uint8_t UART2_TxDataAvailable(void)
392:               {
393:                   uint16_t size;
394:                   uint8_t *snapshot_txHead = (uint8_t*)txHead;
000784  808041     MOV txHead, W1
395:                   
396:                   if (txTail < snapshot_txHead)
000786  808050     MOV txTail, W0
000788  508F80     SUB W1, W0, [W15]
00078A  360003     BRA LEU, .L9
397:                   {
398:                       size = (snapshot_txHead - txTail - 1);
00078C  508080     SUB W1, W0, W1
00078E  E90081     DEC W1, W1
000790  370002     BRA .L10
399:                   }
400:                   else
401:                   {
402:                       size = ( UART2_CONFIG_TX_BYTEQ_LENGTH - (txTail - snapshot_txHead) - 1 );
000792  508080     SUB W1, W0, W1
000794  4080E8     ADD W1, #0x8, W1
403:                   }
404:                   
405:                   if(size > 0xFF)
000798  200FF2     MOV #0xFF, W2
00079A  508F82     SUB W1, W2, [W15]
00079C  3E0001     BRA GTU, .L11
406:                   {
407:                       return 0xFF;
000796  EBC000     SETM.B W0
408:                   }
409:                   
410:                   return size;
00079E  784001     MOV.B W1, W0
411:               }
0007A0  060000     RETURN
412:               
413:               unsigned int __attribute__((deprecated)) UART2_ReadBuffer( uint8_t *buffer ,  unsigned int numbytes)
414:               {
000882  BE9F88     MOV.D W8, [W15++]
000884  781F8A     MOV W10, [W15++]
000886  780480     MOV W0, W9
000888  780401     MOV W1, W8
415:                   unsigned int rx_count = UART2_RxDataAvailable();
00088A  07FF6E     RCALL UART2_RxDataAvailable
00088C  FB8500     ZE W0, W10
00088E  550F88     SUB W10, W8, [W15]
000890  360001     BRA LEU, .L55
000892  780508     MOV W8, W10
416:                   unsigned int i;
417:                   
418:                   if(numbytes < rx_count)
419:                   {
420:                       rx_count = numbytes;
421:                   }
422:                   
423:                   for(i=0; i<rx_count; i++)
000894  E0000A     CP0 W10
000896  320006     BRA Z, .L56
000898  EB0400     CLR W8
00089E  E80408     INC W8, W8
0008A0  540F8A     SUB W8, W10, [W15]
0008A2  39FFFB     BRA NC, .L57
424:                   {
425:                       *buffer++ = UART2_Read();
00089A  07FFB8     RCALL UART2_Read
00089C  785C80     MOV.B W0, [W9++]
426:                   }
427:                   
428:                   return rx_count;    
429:               }
0008A4  78000A     MOV W10, W0
0008A6  78054F     MOV [--W15], W10
0008A8  BE044F     MOV.D [--W15], W8
0008AA  060000     RETURN
430:               
431:               unsigned int __attribute__((deprecated)) UART2_WriteBuffer( uint8_t *buffer , unsigned int numbytes )
432:               {
0008AC  BE9F88     MOV.D W8, [W15++]
0008AE  781F8A     MOV W10, [W15++]
0008B0  780480     MOV W0, W9
0008B2  780401     MOV W1, W8
433:                   unsigned int tx_count = UART2_TxDataAvailable();
0008B4  07FF67     RCALL UART2_TxDataAvailable
0008B6  FB8500     ZE W0, W10
0008B8  550F88     SUB W10, W8, [W15]
0008BA  360001     BRA LEU, .L60
0008BC  780508     MOV W8, W10
434:                   unsigned int i;
435:                   
436:                   if(numbytes < tx_count)
437:                   {
438:                       tx_count = numbytes;
439:                   }
440:                   
441:                   for(i=0; i<tx_count; i++)
0008BE  E0000A     CP0 W10
0008C0  320006     BRA Z, .L61
0008C2  EB0400     CLR W8
0008C8  E80408     INC W8, W8
0008CA  540F8A     SUB W8, W10, [W15]
0008CC  39FFFB     BRA NC, .L62
442:                   {
443:                       UART2_Write(*buffer++);
0008C4  784039     MOV.B [W9++], W0
0008C6  07FFC3     RCALL UART2_Write
444:                   }
445:                   
446:                   return tx_count;  
447:               }
0008CE  78000A     MOV W10, W0
0008D0  78054F     MOV [--W15], W10
0008D2  BE044F     MOV.D [--W15], W8
0008D4  060000     RETURN
448:               
449:               UART2_TRANSFER_STATUS __attribute__((deprecated)) UART2_TransferStatusGet (void )
450:               {
0008D6  781F88     MOV W8, [W15++]
451:                   UART2_TRANSFER_STATUS status = 0;
452:                   uint8_t rx_count = UART2_RxDataAvailable();
0008D8  07FF47     RCALL UART2_RxDataAvailable
0008DA  784400     MOV.B W0, W8
453:                   uint8_t tx_count = UART2_TxDataAvailable();
0008DC  07FF53     RCALL UART2_TxDataAvailable
0008DE  784080     MOV.B W0, W1
454:                   
455:                   switch(rx_count)
0008E2  E00408     CP0.B W8
0008E4  320004     BRA Z, .L67
0008E8  544FE9     SUB.B W8, #0x9, [W15]
0008EA  320001     BRA Z, .L67
456:                   {
457:                       case 0:
458:                           status |= UART2_TRANSFER_STATUS_RX_EMPTY;
0008E0  200040     MOV #0x4, W0
459:                           break;
460:                       case UART2_CONFIG_RX_BYTEQ_LENGTH:
461:                           status |= UART2_TRANSFER_STATUS_RX_FULL;
0008E6  200010     MOV #0x1, W0
462:                           break;
463:                       default:
464:                           status |= UART2_TRANSFER_STATUS_RX_DATA_PRESENT;
0008EC  200020     MOV #0x2, W0
465:                           break;
466:                   }
467:                   
468:                   switch(tx_count)
0008EE  E00401     CP0.B W1
0008F0  320003     BRA Z, .L69
0008F2  50CFE9     SUB.B W1, #0x9, [W15]
0008F4  3A0004     BRA NZ, .L68
0008F6  370002     BRA .L72
469:                   {
470:                       case 0:
471:                           status |= UART2_TRANSFER_STATUS_TX_FULL;
0008F8  A03000     BSET W0, #3
472:                           break;
0008FA  370001     BRA .L68
473:                       case UART2_CONFIG_RX_BYTEQ_LENGTH:
474:                           status |= UART2_TRANSFER_STATUS_TX_EMPTY;
0008FC  A04000     BSET W0, #4
475:                           break;
476:                       default:
477:                           break;
478:                   }
479:               
480:                   return status;    
481:               }
0008FE  78044F     MOV [--W15], W8
000900  060000     RETURN
482:               
483:               uint8_t __attribute__((deprecated)) UART2_Peek(uint16_t offset)
484:               {
485:                   uint8_t *peek = rxHead + offset;
000902  B41004     ADD rxHead, WREG
486:                   
487:                   while(peek > (rxQueue + UART2_CONFIG_RX_BYTEQ_LENGTH))
000904  2103B1     MOV #0x103B, W1
000906  500F81     SUB W0, W1, [W15]
000908  360003     BRA LEU, .L74
00090C  500F81     SUB W0, W1, [W15]
00090E  3EFFFD     BRA GTU, .L76
000910  784010     MOV.B [W0], W0
488:                   {
489:                       peek -= UART2_CONFIG_RX_BYTEQ_LENGTH;
00090A  500069     SUB W0, #0x9, W0
490:                   }
491:                   
492:                   return *peek;
493:               }
000912  060000     RETURN
494:               
495:               bool __attribute__((deprecated)) UART2_ReceiveBufferIsEmpty (void)
496:               {
497:                   return (UART2_RxDataAvailable() == 0);
000914  07FF29     RCALL UART2_RxDataAvailable
000916  FB8000     ZE W0, W0
000918  E90000     DEC W0, W0
00091A  DE004F     LSR W0, #15, W0
498:               }
00091C  060000     RETURN
499:               
500:               bool __attribute__((deprecated)) UART2_TransmitBufferIsFull(void)
501:               {
502:                   return (UART2_TxDataAvailable() == 0);
00091E  07FF32     RCALL UART2_TxDataAvailable
000920  FB8000     ZE W0, W0
000922  E90000     DEC W0, W0
000924  DE004F     LSR W0, #15, W0
503:               }
000926  060000     RETURN
504:               
505:               uint32_t __attribute__((deprecated)) UART2_StatusGet (void)
506:               {
507:                   uint32_t statusReg = U2STAH;
000928  801330     MOV U2STAH, W0
00092C  EB0080     CLR W1
508:                   return ((statusReg << 16 ) | U2STA);
00092A  801322     MOV U2STA, W2
00092E  DD00C0     SL W0, #0, W1
000930  200000     MOV #0x0, W0
000932  EB0180     CLR W3
000934  700002     IOR W0, W2, W0
000936  708083     IOR W1, W3, W1
509:               }
000938  060000     RETURN
510:               
511:               unsigned int __attribute__((deprecated)) UART2_TransmitBufferSizeGet(void)
512:               {
513:                   if(UART2_TxDataAvailable() != 0)
00093A  07FF24     RCALL UART2_TxDataAvailable
00093C  784080     MOV.B W0, W1
000940  E00401     CP0.B W1
000942  320008     BRA Z, .L82
514:                   { 
515:                       if(txHead > txTail)
000944  808050     MOV txTail, W0
000946  E31008     CP txHead
000948  360003     BRA LEU, .L83
516:                       {
517:                           return((txHead - txTail) - 1);
00094A  B51008     SUB txHead, WREG
00094C  E90000     DEC W0, W0
00094E  370002     BRA .L82
518:                       }
519:                       else
520:                       {
521:                           return((UART2_CONFIG_TX_BYTEQ_LENGTH - (txTail - txHead)) - 1);
000950  B51008     SUB txHead, WREG
000952  400068     ADD W0, #0x8, W0
522:                       }
523:                   }
524:                   return 0;
00093E  EB0000     CLR W0
525:               }
000954  060000     RETURN
526:               
527:               unsigned int __attribute__((deprecated)) UART2_ReceiveBufferSizeGet(void)
528:               {
529:                   if(UART2_RxDataAvailable() != 0)
000956  07FF08     RCALL UART2_RxDataAvailable
000958  784080     MOV.B W0, W1
00095C  E00401     CP0.B W1
00095E  32000A     BRA Z, .L86
530:                   {
531:                       if(rxHead > rxTail)
000960  808020     MOV rxHead, W0
000962  E31006     CP rxTail
000964  310004     BRA C, .L87
532:                       {
533:                           return((rxHead - rxTail) - 1);
000966  808031     MOV rxTail, W1
000968  500001     SUB W0, W1, W0
00096A  E90000     DEC W0, W0
00096C  370003     BRA .L86
534:                       }
535:                       else
536:                       {
537:                           return((UART2_CONFIG_RX_BYTEQ_LENGTH - (rxTail - rxHead)) - 1);
00096E  808031     MOV rxTail, W1
000970  500001     SUB W0, W1, W0
000972  400068     ADD W0, #0x8, W0
538:                       } 
539:                   }
540:                   return 0;
00095A  EB0000     CLR W0
541:               }
000974  060000     RETURN
542:               
543:               void __attribute__((deprecated)) UART2_Enable(void)
544:               {
545:                   U2MODEbits.UARTEN = 1;
000976  A8E261     BSET 0x261, #7
546:                   U2MODEbits.UTXEN = 1; 
000978  A8A260     BSET U2MODE, #5
547:                   U2MODEbits.URXEN = 1;
00097A  A88260     BSET U2MODE, #4
548:               }
00097C  060000     RETURN
549:               
550:               void __attribute__((deprecated)) UART2_Disable(void)
551:               {
552:                   U2MODEbits.UARTEN = 0;
00097E  A9E261     BCLR 0x261, #7
553:                   U2MODEbits.UTXEN = 0; 
000980  A9A260     BCLR U2MODE, #5
554:                   U2MODEbits.URXEN = 0;
000982  A98260     BCLR U2MODE, #4
555:               }
000984  060000     RETURN
---  C:/Cust_Tests/CKAutoBaud/CKABaud081622.X/mcc_generated_files/uart1.c  ------------------------------
1:                 /**
2:                   UART1 Generated Driver File
3:                 
4:                   @Company
5:                     Microchip Technology Inc.
6:                 
7:                   @File Name
8:                     uart1.c
9:                 
10:                  @Summary
11:                    This is the generated driver implementation file for the UART1 driver using PIC24 / dsPIC33 / PIC32MM MCUs
12:                
13:                  @Description
14:                    This header file provides implementations for driver APIs for UART1.
15:                    Generation Information :
16:                        Product Revision  :  PIC24 / dsPIC33 / PIC32MM MCUs - 1.171.1
17:                        Device            :  dsPIC33CK256MP506
18:                    The generated drivers are tested against the following:
19:                        Compiler          :  XC16 v1.70
20:                        MPLAB             :  MPLAB X v5.50
21:                */
22:                
23:                /*
24:                    (c) 2020 Microchip Technology Inc. and its subsidiaries. You may use this
25:                    software and any derivatives exclusively with Microchip products.
26:                
27:                    THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
28:                    EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
29:                    WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
30:                    PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP PRODUCTS, COMBINATION
31:                    WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
32:                
33:                    IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
34:                    INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
35:                    WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
36:                    BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
37:                    FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
38:                    ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
39:                    THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
40:                
41:                    MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE
42:                    TERMS.
43:                */
44:                
45:                /**
46:                  Section: Included Files
47:                */
48:                #include <xc.h>
49:                #include "uart1.h"
50:                
51:                /**
52:                  Section: UART1 APIs
53:                */
54:                
55:                void UART1_Initialize(void)
56:                {
57:                /**    
58:                     Set the UART1 module to the options selected in the user interface.
59:                     Make sure to set LAT bit corresponding to TxPin as high before UART initialization
60:                */
61:                    // URXEN disabled; RXBIMD RXBKIF flag when Break makes low-to-high transition after being low for at least 23/11 bit periods; UARTEN enabled; MOD Asynchronous 8-bit UART; UTXBRK disabled; BRKOVR TX line driven by shifter; UTXEN disabled; USIDL disabled; WAKE disabled; ABAUD disabled; BRGH enabled; 
62:                    // Data Bits = 8; Parity = None; Stop Bits = 1 Stop bit sent, 1 checked at RX;
63:                    U1MODE = (0x8080 & ~(1<<15));  // disabling UARTEN bit
000AC2  200800     MOV #0x80, W0
000AC4  8811C0     MOV W0, U1MODE
64:                    // STSEL 1 Stop bit sent, 1 checked at RX; BCLKMOD disabled; SLPEN disabled; FLO Off; BCLKSEL FOSC/2; C0EN disabled; RUNOVF disabled; UTXINV disabled; URXINV disabled; HALFDPLX disabled; 
65:                    U1MODEH = 0x00;
000AC6  EF223A     CLR U1MODEH
66:                    // OERIE disabled; RXBKIF disabled; RXBKIE disabled; ABDOVF disabled; OERR disabled; TXCIE disabled; TXCIF disabled; FERIE disabled; TXMTIE disabled; ABDOVE disabled; CERIE disabled; CERIF disabled; PERIE disabled; 
67:                    U1STA = 0x00;
000AC8  EF223C     CLR U1STA
68:                    // URXISEL RX_ONE_WORD; UTXBE enabled; UTXISEL TX_BUF_EMPTY; URXBE enabled; STPMD disabled; TXWRE disabled; 
69:                    U1STAH = 0x22;
000ACA  200220     MOV #0x22, W0
000ACC  8811F0     MOV W0, U1STAH
70:                    // BaudRate = 115200; Frequency = 100000000 Hz; BRG 216; 
71:                    U1BRG = 0xD8;
000ACE  200D80     MOV #0xD8, W0
000AD0  881200     MOV W0, U1BRG
72:                    // BRG 0; 
73:                    U1BRGH = 0x00;
000AD2  EF2242     CLR U1BRGH
74:                    // P1 0; 
75:                    U1P1 = 0x00;
000AD4  EF224C     CLR U1P1
76:                    // P2 0; 
77:                    U1P2 = 0x00;
000AD6  EF224E     CLR U1P2
78:                    // P3 0; 
79:                    U1P3 = 0x00;
000AD8  EF2250     CLR U1P3
80:                    // P3H 0; 
81:                    U1P3H = 0x00;
000ADA  EF2252     CLR U1P3H
82:                    // TXCHK 0; 
83:                    U1TXCHK = 0x00;
000ADC  EF2254     CLR U1TXCHK
84:                    // RXCHK 0; 
85:                    U1RXCHK = 0x00;
000ADE  EF2256     CLR U1RXCHK
86:                    // T0PD 1 ETU; PTRCL disabled; TXRPT Retransmit the error byte once; CONV Direct logic; 
87:                    U1SCCON = 0x00;
000AE0  EF2258     CLR U1SCCON
88:                    // TXRPTIF disabled; TXRPTIE disabled; WTCIF disabled; WTCIE disabled; BTCIE disabled; BTCIF disabled; GTCIF disabled; GTCIE disabled; RXRPTIE disabled; RXRPTIF disabled; 
89:                    U1SCINT = 0x00;
000AE2  EF225A     CLR U1SCINT
90:                    // ABDIF disabled; WUIF disabled; ABDIE disabled; 
91:                    U1INT = 0x00;
000AE4  EF225C     CLR U1INT
92:                    
93:                    U1MODEbits.UARTEN = 1;   // enabling UART ON bit
000AE6  A8E239     BSET 0x239, #7
94:                    U1MODEbits.UTXEN = 1;
000AE8  A8A238     BSET U1MODE, #5
95:                    U1MODEbits.URXEN = 1;
000AEA  A88238     BSET U1MODE, #4
96:                }
000AEC  060000     RETURN
97:                
98:                uint8_t UART1_Read(void)
99:                {
100:                   while((U1STAHbits.URXBE == 1))
000AEE  AB223E     BTST U1STAH, #1
000AF0  3AFFFE     BRA NZ, UART1_Read
101:                   {
102:                       
103:                   }
104:               
105:                   if ((U1STAbits.OERR == 1))
000AF2  AB223C     BTST U1STA, #1
000AF4  320001     BRA Z, .L4
106:                   {
107:                       U1STAbits.OERR = 0;
000AF6  A9223C     BCLR U1STA, #1
108:                   }
109:                   
110:                   return U1RXREG;
000AF8  801220     MOV U1RXREG, W0
111:               }
000AFA  060000     RETURN
112:               
113:               void UART1_Write(uint8_t txData)
114:               {
115:                   while(U1STAHbits.UTXBF == 1)
000AFC  AB823E     BTST U1STAH, #4
000AFE  3AFFFE     BRA NZ, UART1_Write
116:                   {
117:                       
118:                   }
119:               
120:                   U1TXREG = txData;    // Write the data byte to the USART.
000B00  FB8000     ZE W0, W0
000B02  881240     MOV W0, U1TXREG
121:               }
000B04  060000     RETURN
122:               
123:               bool UART1_IsRxReady(void)
124:               {
125:                   return (U1STAHbits.URXBE == 0);
000B06  8011F0     MOV U1STAH, W0
000B08  A21000     BTG W0, #1
000B0A  0A8011     BFEXT #0x1, #0x1, W0, W0
000B0C  000000     NOP
126:               }
000B0E  060000     RETURN
127:               
128:               bool UART1_IsTxReady(void)
000B16  200200     MOV #0x20, W0
000B18  B60238     AND U1MODE, WREG
000B1A  EA0000     NEG W0, W0
129:               {
130:                   return ((!U1STAHbits.UTXBF) && U1MODEbits.UTXEN );
000B10  EB0000     CLR W0
000B12  AB823E     BTST U1STAH, #4
000B14  3A0004     BRA NZ, .L11
000B1C  DE004F     LSR W0, #15, W0
131:               }
000B1E  060000     RETURN
132:               
133:               bool UART1_IsTxDone(void)
134:               {
135:                   return U1STAbits.TRMT;
000B20  0AA077     BFEXT #0x7, #0x1, U1STA, W0
000B22  00023C     NOP
136:               }
000B24  060000     RETURN
137:               
138:               
139:               /*******************************************************************************
140:               
141:                 !!! Deprecated API !!!
142:                 !!! These functions will not be supported in future releases !!!
143:               
144:               *******************************************************************************/
145:               
146:               uint32_t __attribute__((deprecated)) UART1_StatusGet (void)
147:               {
148:                   uint32_t statusReg = U1STAH;
000B26  8011F0     MOV U1STAH, W0
000B2A  EB0080     CLR W1
149:                   return ((statusReg << 16 ) | U1STA);
000B28  8011E2     MOV U1STA, W2
000B2C  DD00C0     SL W0, #0, W1
000B2E  200000     MOV #0x0, W0
000B30  EB0180     CLR W3
000B32  700002     IOR W0, W2, W0
000B34  708083     IOR W1, W3, W1
150:               }
000B36  060000     RETURN
151:               
152:               void __attribute__((deprecated)) UART1_Enable(void)
153:               {
154:                   U1MODEbits.UARTEN = 1;
000B38  A8E239     BSET 0x239, #7
155:                   U1MODEbits.UTXEN = 1; 
000B3A  A8A238     BSET U1MODE, #5
156:                   U1MODEbits.URXEN = 1;
000B3C  A88238     BSET U1MODE, #4
157:               }
000B3E  060000     RETURN
158:               
159:               void __attribute__((deprecated)) UART1_Disable(void)
160:               {
161:                   U1MODEbits.UARTEN = 0;
000B40  A9E239     BCLR 0x239, #7
162:                   U1MODEbits.UTXEN = 0; 
000B42  A9A238     BCLR U1MODE, #5
163:                   U1MODEbits.URXEN = 0;
000B44  A98238     BCLR U1MODE, #4
164:               }
000B46  060000     RETURN
165:               
166:               
---  C:/Cust_Tests/CKAutoBaud/CKABaud081622.X/mcc_generated_files/traps.c  ------------------------------
1:                 /**
2:                   System Traps Generated Driver File 
3:                 
4:                   @Company:
5:                     Microchip Technology Inc.
6:                 
7:                   @File Name:
8:                     traps.h
9:                 
10:                  @Summary:
11:                    This is the generated driver implementation file for handling traps
12:                    using PIC24 / dsPIC33 / PIC32MM MCUs
13:                
14:                  @Description:
15:                    This source file provides implementations for PIC24 / dsPIC33 / PIC32MM MCUs traps.
16:                    Generation Information : 
17:                        Product Revision  :  PIC24 / dsPIC33 / PIC32MM MCUs - 1.171.1
18:                        Device            :  dsPIC33CK256MP506
19:                    The generated drivers are tested against the following:
20:                        Compiler          :  XC16 v1.70
21:                        MPLAB             :  MPLAB X v5.50
22:                */
23:                /*
24:                    (c) 2020 Microchip Technology Inc. and its subsidiaries. You may use this
25:                    software and any derivatives exclusively with Microchip products.
26:                
27:                    THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
28:                    EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
29:                    WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
30:                    PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP PRODUCTS, COMBINATION
31:                    WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
32:                
33:                    IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
34:                    INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
35:                    WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
36:                    BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
37:                    FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
38:                    ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
39:                    THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
40:                
41:                    MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE
42:                    TERMS.
43:                */
44:                
45:                /**
46:                    Section: Includes
47:                */
48:                #include <xc.h>
49:                #include "traps.h"
50:                
51:                #define ERROR_HANDLER __attribute__((interrupt, no_auto_psv, keep, section("error_handler")))
52:                #define FAILSAFE_STACK_GUARDSIZE 8
53:                
54:                /**
55:                 * a private place to store the error code if we run into a severe error
56:                 */
57:                static uint16_t TRAPS_error_code = -1;
58:                
59:                /**
60:                 * Halts 
61:                 * 
62:                 * @param code error code
63:                 */
64:                void __attribute__((weak)) TRAPS_halt_on_error(uint16_t code)
65:                {
66:                    TRAPS_error_code = code;
000D24  888070     MOV W0, 0x100E
000D26  37FFFF     BRA .L3
67:                #ifdef __DEBUG    
68:                    __builtin_software_breakpoint();
69:                    /* If we are in debug mode, cause a software breakpoint in the debugger */
70:                #endif
71:                    while(1);
72:                    
73:                }
74:                
75:                /**
76:                 * Sets the stack pointer to a backup area of memory, in case we run into
77:                 * a stack error (in which case we can't really trust the stack pointer)
78:                 */
79:                inline static void use_failsafe_stack(void)
80:                {
81:                    static uint8_t failsafe_stack[32];
82:                    asm volatile (
000D1A  210120     MOV #0x1012, W0
000D1C  780780     MOV W0, W15
83:                        "   mov    %[pstack], W15\n"
84:                        :
85:                        : [pstack]"r"(failsafe_stack)
86:                    );
87:                /* Controls where the stack pointer limit is, relative to the end of the
88:                 * failsafe stack
89:                 */    
90:                    SPLIM = (uint16_t)(((uint8_t *)failsafe_stack) + sizeof(failsafe_stack) 
000D1E  2102A0     MOV #0x102A, W0
000D20  880100     MOV W0, SPLIM
91:                            - FAILSAFE_STACK_GUARDSIZE);
92:                }
000D22  060000     RETURN
93:                
94:                
95:                /** Oscillator Fail Trap vector**/
96:                void ERROR_HANDLER _OscillatorFail(void)
97:                {
000306  F80036     PUSH RCOUNT
000308  BE9F80     MOV.D W0, [W15++]
00030A  BE9F82     MOV.D W2, [W15++]
00030C  BE9F84     MOV.D W4, [W15++]
00030E  BE9F86     MOV.D W6, [W15++]
98:                    INTCON1bits.OSCFAIL = 0;  //Clear the trap flag
000310  A928C0     BCLR INTCON1, #1
99:                    TRAPS_halt_on_error(TRAPS_OSC_FAIL);
000312  EB0000     CLR W0
000314  070507     RCALL TRAPS_halt_on_error
100:               }
000316  BE034F     MOV.D [--W15], W6
000318  BE024F     MOV.D [--W15], W4
00031A  BE014F     MOV.D [--W15], W2
00031C  BE004F     MOV.D [--W15], W0
00031E  F90036     POP RCOUNT
000320  064000     RETFIE
101:               /** Stack Error Trap Vector**/
102:               void ERROR_HANDLER _StackError(void)
103:               {
000322  F80036     PUSH RCOUNT
000324  BE9F80     MOV.D W0, [W15++]
000326  BE9F82     MOV.D W2, [W15++]
000328  BE9F84     MOV.D W4, [W15++]
00032A  BE9F86     MOV.D W6, [W15++]
104:                   /* We use a failsafe stack: the presence of a stack-pointer error
105:                    * means that we cannot trust the stack to operate correctly unless
106:                    * we set the stack pointer to a safe place.
107:                    */
108:                   use_failsafe_stack(); 
00032C  0704F6     RCALL use_failsafe_stack
109:                   INTCON1bits.STKERR = 0;  //Clear the trap flag
00032E  A948C0     BCLR INTCON1, #2
110:                   TRAPS_halt_on_error(TRAPS_STACK_ERR);
000330  200010     MOV #0x1, W0
000332  0704F8     RCALL TRAPS_halt_on_error
111:               }
000334  BE034F     MOV.D [--W15], W6
000336  BE024F     MOV.D [--W15], W4
000338  BE014F     MOV.D [--W15], W2
00033A  BE004F     MOV.D [--W15], W0
00033C  F90036     POP RCOUNT
00033E  064000     RETFIE
112:               /** Address error Trap vector**/
113:               void ERROR_HANDLER _AddressError(void)
114:               {
000340  F80036     PUSH RCOUNT
000342  BE9F80     MOV.D W0, [W15++]
000344  BE9F82     MOV.D W2, [W15++]
000346  BE9F84     MOV.D W4, [W15++]
000348  BE9F86     MOV.D W6, [W15++]
115:                   INTCON1bits.ADDRERR = 0;  //Clear the trap flag
00034A  A968C0     BCLR INTCON1, #3
116:                   TRAPS_halt_on_error(TRAPS_ADDRESS_ERR);
00034C  200020     MOV #0x2, W0
00034E  0704EA     RCALL TRAPS_halt_on_error
117:               }
000350  BE034F     MOV.D [--W15], W6
000352  BE024F     MOV.D [--W15], W4
000354  BE014F     MOV.D [--W15], W2
000356  BE004F     MOV.D [--W15], W0
000358  F90036     POP RCOUNT
00035A  064000     RETFIE
118:               /** Math Error Trap vector**/
119:               void ERROR_HANDLER _MathError(void)
120:               {
00035C  F80036     PUSH RCOUNT
00035E  BE9F80     MOV.D W0, [W15++]
000360  BE9F82     MOV.D W2, [W15++]
000362  BE9F84     MOV.D W4, [W15++]
000364  BE9F86     MOV.D W6, [W15++]
121:                   INTCON1bits.MATHERR = 0;  //Clear the trap flag
000366  A988C0     BCLR INTCON1, #4
122:                   TRAPS_halt_on_error(TRAPS_MATH_ERR);
000368  200030     MOV #0x3, W0
00036A  0704DC     RCALL TRAPS_halt_on_error
123:               }
00036C  BE034F     MOV.D [--W15], W6
00036E  BE024F     MOV.D [--W15], W4
000370  BE014F     MOV.D [--W15], W2
000372  BE004F     MOV.D [--W15], W0
000374  F90036     POP RCOUNT
000376  064000     RETFIE
124:               /** Generic Hard Trap vector**/
125:               void ERROR_HANDLER _HardTrapError(void)
126:               {
000378  F80036     PUSH RCOUNT
00037A  BE9F80     MOV.D W0, [W15++]
00037C  BE9F82     MOV.D W2, [W15++]
00037E  BE9F84     MOV.D W4, [W15++]
000380  BE9F86     MOV.D W6, [W15++]
127:                   INTCON4bits.SGHT = 0;  //Clear the trap flag
000382  A908C6     BCLR INTCON4, #0
128:                   TRAPS_halt_on_error(TRAPS_HARD_ERR);
000384  200070     MOV #0x7, W0
000386  0704CE     RCALL TRAPS_halt_on_error
129:               }
000388  BE034F     MOV.D [--W15], W6
00038A  BE024F     MOV.D [--W15], W4
00038C  BE014F     MOV.D [--W15], W2
00038E  BE004F     MOV.D [--W15], W0
000390  F90036     POP RCOUNT
000392  064000     RETFIE
130:               /** Generic Soft Trap vector**/
131:               void ERROR_HANDLER _SoftTrapError(void)
132:               {
000394  F80036     PUSH RCOUNT
000396  BE9F80     MOV.D W0, [W15++]
000398  BE9F82     MOV.D W2, [W15++]
00039A  BE9F84     MOV.D W4, [W15++]
00039C  BE9F86     MOV.D W6, [W15++]
133:                   if(INTCON3bits.NAE)
00039E  AB08C5     BTST 0x8C5, #0
0003A0  320003     BRA Z, .L10
134:                   {
135:                     INTCON3bits.NAE = 0;  //Clear the trap flag
0003A2  A908C5     BCLR 0x8C5, #0
136:                     TRAPS_halt_on_error(TRAPS_NVM_ERR);
0003A4  2000C0     MOV #0xC, W0
0003A6  0704BE     RCALL TRAPS_halt_on_error
137:                   }
138:               
139:               #ifdef _DMT
140:                   if(INTCON3bits.DMT)
141:                   {
142:                     INTCON3bits.DMT = 0;  //Clear the trap flag
143:                     TRAPS_halt_on_error(TRAPS_DMT_ERR);
144:                   }
145:               
146:               #endif
147:               #ifdef _DAE
148:                   if(INTCON3bits.DAE)
149:                   {
150:                     INTCON3bits.DAE = 0;  //Clear the trap flag
151:                     TRAPS_halt_on_error(TRAPS_DAE_ERR);
152:                   }
153:               
154:               #endif
155:                   if(INTCON3bits.DOOVR)
0003A8  AB88C4     BTST INTCON3, #4
0003AA  320003     BRA Z, .L11
156:                   {
157:                     INTCON3bits.DOOVR = 0;  //Clear the trap flag
0003AC  A988C4     BCLR INTCON3, #4
158:                     TRAPS_halt_on_error(TRAPS_DOOVR_ERR);
0003AE  2000A0     MOV #0xA, W0
0003B0  0704B9     RCALL TRAPS_halt_on_error
159:                   }
160:               
161:                   if(INTCON3bits.APLL)
0003B2  AB08C4     BTST INTCON3, #0
0003B4  320003     BRA Z, .L12, .L13
162:                   {
163:                     INTCON3bits.APLL = 0;  //Clear the trap flag
0003B6  A908C4     BCLR INTCON3, #0
164:                     TRAPS_halt_on_error(TRAPS_APLL_ERR);
0003B8  2000B0     MOV #0xB, W0
0003BA  0704B4     RCALL TRAPS_halt_on_error
0003BC  37FFFF     BRA .L12, .L13
165:                   }
166:               
167:                   while(1);
168:               }
169:               
170:               
---  C:/Cust_Tests/CKAutoBaud/CKABaud081622.X/mcc_generated_files/tmr1.c  -------------------------------
1:                 
2:                 /**
3:                   TMR1 Generated Driver API Source File 
4:                 
5:                   @Company
6:                     Microchip Technology Inc.
7:                 
8:                   @File Name
9:                     tmr1.c
10:                
11:                  @Summary
12:                    This is the generated source file for the TMR1 driver using PIC24 / dsPIC33 / PIC32MM MCUs
13:                
14:                  @Description
15:                    This source file provides APIs for driver for TMR1. 
16:                    Generation Information : 
17:                        Product Revision  :  PIC24 / dsPIC33 / PIC32MM MCUs - 1.171.1
18:                        Device            :  dsPIC33CK256MP506
19:                    The generated drivers are tested against the following:
20:                        Compiler          :  XC16 v1.70
21:                        MPLAB             :  MPLAB X v5.50
22:                */
23:                
24:                /*
25:                    (c) 2020 Microchip Technology Inc. and its subsidiaries. You may use this
26:                    software and any derivatives exclusively with Microchip products.
27:                
28:                    THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
29:                    EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
30:                    WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
31:                    PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP PRODUCTS, COMBINATION
32:                    WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
33:                
34:                    IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
35:                    INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
36:                    WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
37:                    BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
38:                    FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
39:                    ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
40:                    THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
41:                
42:                    MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE
43:                    TERMS.
44:                */
45:                
46:                /**
47:                  Section: Included Files
48:                */
49:                
50:                #include <stdio.h>
51:                #include "tmr1.h"
52:                
53:                /**
54:                 Section: File specific functions
55:                */
56:                void (*TMR1_InterruptHandler)(void) = NULL;
57:                void TMR1_CallBack(void);
58:                
59:                /**
60:                  Section: Data Type Definitions
61:                */
62:                
63:                /** TMR Driver Hardware Instance Object
64:                
65:                  @Summary
66:                    Defines the object required for the maintenance of the hardware instance.
67:                
68:                  @Description
69:                    This defines the object required for the maintenance of the hardware
70:                    instance. This object exists once per hardware instance of the peripheral.
71:                
72:                  Remarks:
73:                    None.
74:                */
75:                
76:                typedef struct _TMR_OBJ_STRUCT
77:                {
78:                    /* Timer Elapsed */
79:                    volatile bool           timerElapsed;
80:                    /*Software Counter value*/
81:                    volatile uint8_t        count;
82:                
83:                } TMR_OBJ;
84:                
85:                static TMR_OBJ tmr1_obj;
86:                
87:                /**
88:                  Section: Driver Interface
89:                */
90:                
91:                void TMR1_Initialize (void)
92:                {
93:                    //TMR 0; 
94:                    TMR1 = 0x00;
000BDA  EF2104     CLR TMR1
95:                    //Period = 0.11534336 s; Frequency = 100000000 Hz; PR 45055; 
96:                    PR1 = 0xAFFF;
000BDC  2AFFF0     MOV #0xAFFF, W0
000BDE  880840     MOV W0, PR1
97:                    //TCKPS 1:256; PRWIP Write complete; TMWIP Write complete; TON enabled; TSIDL disabled; TCS External; TECS FCY; TSYNC disabled; TMWDIS disabled; TGATE disabled; 
98:                    T1CON = 0x8132;
000BE0  281320     MOV #0x8132, W0
000BE2  880800     MOV W0, T1CON
99:                
100:                   if(TMR1_InterruptHandler == NULL)
000BE4  E21010     CP0 TMR1_InterruptHandler
000BE6  3A0002     BRA NZ, .L10
101:                   {
102:                       TMR1_SetInterruptHandler(&TMR1_CallBack);
000BE8  20BB80     MOV #0xBB8, W0
000BEA  07FFF3     RCALL TMR1_SetInterruptHandler
103:                   }
104:               
105:                   IFS0bits.T1IF = false;
000BEC  A92800     BCLR IFS0, #1
106:                   IEC0bits.T1IE = true;
000BEE  A82820     BSET IEC0, #1
107:               	
108:                   tmr1_obj.timerElapsed = false;
000BF0  210440     MOV #0x1044, W0
000BF2  EB4800     CLR.B [W0]
109:               
110:               }
000BF4  060000     RETURN
111:               
112:               
113:               void __attribute__ ( ( interrupt, no_auto_psv) ) _T1Interrupt (  )
114:               {
0003BE  F80036     PUSH RCOUNT
0003C0  BE9F80     MOV.D W0, [W15++]
0003C2  BE9F82     MOV.D W2, [W15++]
0003C4  BE9F84     MOV.D W4, [W15++]
0003C6  BE9F86     MOV.D W6, [W15++]
115:                   /* Check if the Timer Interrupt/Status is set */
116:               
117:                   //***User Area Begin
118:               
119:                   // ticker function call;
120:                   // ticker is 1 -> Callback function gets called everytime this ISR executes
121:                   if(TMR1_InterruptHandler) 
0003C8  808080     MOV TMR1_InterruptHandler, W0
0003CA  E00000     CP0 W0
0003CC  320001     BRA Z, .L3
122:                   { 
123:                          TMR1_InterruptHandler(); 
0003CE  010000     CALL W0
124:                   }
125:               
126:                   //***User Area End
127:               
128:                   tmr1_obj.count++;
0003D0  210450     MOV #0x1045, W0
0003D2  E84810     INC.B [W0], [W0]
129:                   tmr1_obj.timerElapsed = true;
0003D4  B3C011     MOV.B #0x1, W1
0003D6  210440     MOV #0x1044, W0
0003D8  784801     MOV.B W1, [W0]
130:                   IFS0bits.T1IF = false;
0003DA  A92800     BCLR IFS0, #1
131:               }
0003DC  BE034F     MOV.D [--W15], W6
0003DE  BE024F     MOV.D [--W15], W4
0003E0  BE014F     MOV.D [--W15], W2
0003E2  BE004F     MOV.D [--W15], W0
0003E4  F90036     POP RCOUNT
0003E6  064000     RETFIE
132:               
133:               void TMR1_Period16BitSet( uint16_t value )
134:               {
135:                   /* Update the counter values */
136:                   PR1 = value;
000BBA  880840     MOV W0, PR1
137:                   /* Reset the status information */
138:                   tmr1_obj.timerElapsed = false;
000BBC  210440     MOV #0x1044, W0
000BBE  EB4800     CLR.B [W0]
139:               }
000BC0  060000     RETURN
140:               
141:               uint16_t TMR1_Period16BitGet( void )
142:               {
143:                   return( PR1 );
000BC2  800840     MOV PR1, W0
144:               }
000BC4  060000     RETURN
145:               
146:               void TMR1_Counter16BitSet ( uint16_t value )
147:               {
148:                   /* Update the counter values */
149:                   TMR1 = value;
000BC6  880820     MOV W0, TMR1
150:                   /* Reset the status information */
151:                   tmr1_obj.timerElapsed = false;
000BC8  210440     MOV #0x1044, W0
000BCA  EB4800     CLR.B [W0]
152:               }
000BCC  060000     RETURN
153:               
154:               uint16_t TMR1_Counter16BitGet( void )
155:               {
156:                   return( TMR1 );
000BCE  800820     MOV TMR1, W0
157:               }
000BD0  060000     RETURN
158:               
159:               
160:               void __attribute__ ((weak)) TMR1_CallBack(void)
161:               {
162:                   // Add your custom callback code here
163:               }
000BB8  060000     RETURN
164:               
165:               void  TMR1_SetInterruptHandler(void (* InterruptHandler)(void))
166:               { 
167:                   IEC0bits.T1IE = false;
000BD2  A92820     BCLR IEC0, #1
168:                   TMR1_InterruptHandler = InterruptHandler; 
000BD4  888080     MOV W0, TMR1_InterruptHandler
169:                   IEC0bits.T1IE = true;
000BD6  A82820     BSET IEC0, #1
170:               }
000BD8  060000     RETURN
171:               
172:               void TMR1_Start( void )
173:               {
174:                   /* Reset the status information */
175:                   tmr1_obj.timerElapsed = false;
000BF6  210440     MOV #0x1044, W0
000BF8  EB4800     CLR.B [W0]
176:               
177:                   /*Enable the interrupt*/
178:                   IEC0bits.T1IE = true;
000BFA  A82820     BSET IEC0, #1
179:               
180:                   /* Start the Timer */
181:                   T1CONbits.TON = 1;
000BFC  A8E101     BSET 0x101, #7
182:               }
000BFE  060000     RETURN
183:               
184:               void TMR1_Stop( void )
185:               {
186:                   /* Stop the Timer */
187:                   T1CONbits.TON = false;
000C00  A9E101     BCLR 0x101, #7
188:               
189:                   /*Disable the interrupt*/
190:                   IEC0bits.T1IE = false;
000C02  A92820     BCLR IEC0, #1
191:               }
000C04  060000     RETURN
192:               
193:               bool TMR1_GetElapsedThenClear(void)
194:               {
195:                   bool status;
196:                   
197:                   status = tmr1_obj.timerElapsed;
000C06  210440     MOV #0x1044, W0
000C08  784010     MOV.B [W0], W0
198:               
199:                   if(status == true)
000C0A  E00400     CP0.B W0
000C0C  320002     BRA Z, .L14
200:                   {
201:                       tmr1_obj.timerElapsed = false;
000C0E  210441     MOV #0x1044, W1
000C10  EB4880     CLR.B [W1]
202:                   }
203:                   return status;
204:               }
000C12  060000     RETURN
205:               
206:               int TMR1_SoftwareCounterGet(void)
207:               {
208:                   return tmr1_obj.count;
000C14  210450     MOV #0x1045, W0
000C16  FB8010     ZE [W0], W0
209:               }
000C18  060000     RETURN
210:               
211:               void TMR1_SoftwareCounterClear(void)
212:               {
213:                   tmr1_obj.count = 0; 
000C1A  210450     MOV #0x1045, W0
000C1C  EB4800     CLR.B [W0]
214:               }
000C1E  060000     RETURN
215:               
216:               /**
217:                End of File
218:               */
---  C:/Cust_Tests/CKAutoBaud/CKABaud081622.X/mcc_generated_files/system.h  -----------------------------
1:                 /**
2:                   @Generated PIC24 / dsPIC33 / PIC32MM MCUs Source File
3:                 
4:                   @Company:
5:                     Microchip Technology Inc.
6:                 
7:                   @File Name:
8:                     system.h
9:                 
10:                  @Summary:
11:                    This is the system.h file generated using PIC24 / dsPIC33 / PIC32MM MCUs
12:                
13:                  @Description:
14:                    This header file provides implementations for driver APIs for all modules selected in the GUI.
15:                    Generation Information :
16:                        Product Revision  :  PIC24 / dsPIC33 / PIC32MM MCUs - 1.171.1
17:                        Device            :  dsPIC33CK256MP506
18:                    The generated drivers are tested against the following:
19:                        Compiler          :  XC16 v1.70
20:                        MPLAB             :  MPLAB X v5.50
21:                */
22:                
23:                /*
24:                    (c) 2020 Microchip Technology Inc. and its subsidiaries. You may use this
25:                    software and any derivatives exclusively with Microchip products.
26:                
27:                    THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
28:                    EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
29:                    WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
30:                    PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP PRODUCTS, COMBINATION
31:                    WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
32:                
33:                    IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
34:                    INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
35:                    WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
36:                    BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
37:                    FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
38:                    ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
39:                    THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
40:                
41:                    MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE
42:                    TERMS.
43:                */
44:                
45:                #ifndef _XTAL_FREQ
46:                #define _XTAL_FREQ  200000000UL
47:                #endif
48:                #define WDT_CLR_KEY 0x5743
49:                
50:                #include "xc.h"
51:                #include "stdint.h"
52:                #include "system_types.h"
53:                
54:                #ifndef SYSTEM_H
55:                #define	SYSTEM_H
56:                /**
57:                 * Initializes the CPU core control register.
58:                 * @example
59:                 * <code>
60:                 * SYSTEM_CORCONInitialize();
61:                 * </code>
62:                 */
63:                inline static void SYSTEM_CORCONInitialize()
64:                {
65:                    CORCON = (CORCON & 0x00F2) | CORCON_MODE_PORVALUES;    // POR value
66:                }
67:                
68:                /**
69:                 * Sets the CPU core control register operating mode to a value that is decided by the
70:                 * SYSTEM_CORCON_MODES argument.
71:                 * @param modeValue SYSTEM_CORCON_MODES initialization mode specifier
72:                 * @example
73:                 * <code>
74:                 * SYSTEM_CORCONModeOperatingSet(CORCON_MODE_ENABLEALLSATNORMAL_ROUNDUNBIASED);
75:                 * </code>
76:                 */
77:                inline static void SYSTEM_CORCONModeOperatingSet(SYSTEM_CORCON_MODES modeValue)
78:                {
79:                    CORCON = (CORCON & 0x00F2) | modeValue;
000CAE  200F21     MOV #0xF2, W1
000CB0  800222     MOV CORCON, W2
000CB2  608082     AND W1, W2, W1
000CB4  708080     IOR W1, W0, W1
000CB6  880221     MOV W1, CORCON
80:                }
000CB8  060000     RETURN
81:                
82:                /**
83:                 * Sets the value of CPU core control register.
84:                 * @param value value that needs to be written to the CPU core control register
85:                 * @example
86:                 * <code>
87:                 *  SYSTEM_CORCONRegisterValueSet(0x00E2);
88:                 * </code>
89:                 */
90:                inline static void SYSTEM_CORCONRegisterValueSet(uint16_t value)
91:                {
92:                    CORCON = value;
93:                }
94:                
95:                /**
96:                 * Gets the value of CPU core control register.
97:                 * @return value of the CPU core control register
98:                 * @example
99:                 * <code>
100:                * corconSave = SYSTEM_CORCONRegisterValueGet();
101:                * </code>
102:                */
103:               inline static uint16_t SYSTEM_CORCONRegisterValueGet(void)
104:               {    
105:                   return CORCON;
106:               }
107:               
108:               
109:               /**
110:                * Gets the base address of the DEVID register for the currently selected device
111:                * @return base address of the DEVID register
112:                * @example
113:                * <code>
114:                * uint32_t devIdAddress;
115:                * devIdAddress = SYSTEM_DeviceIdRegisterAddressGet();
116:                * </code>
117:                */
118:               inline static uint32_t SYSTEM_DeviceIdRegisterAddressGet(void)
119:               {
120:                   return __DEVID_BASE;
121:               }
122:               
123:               /**
124:                * @Param
125:                   none
126:                * @Returns
127:                   none
128:                * @Description
129:                   Initializes the device to the default states configured in the
130:                *                  MCC GUI
131:                * @Example
132:                   SYSTEM_Initialize(void);
133:                */
134:               void SYSTEM_Initialize(void);
135:               #endif	/* SYSTEM_H */
136:               /**
137:                End of File
138:               */
---  C:/Cust_Tests/CKAutoBaud/CKABaud081622.X/mcc_generated_files/system.c  -----------------------------
1:                 /**
2:                   @Generated PIC24 / dsPIC33 / PIC32MM MCUs Source File
3:                 
4:                   @Company:
5:                     Microchip Technology Inc.
6:                 
7:                   @File Name:
8:                     system.h
9:                 
10:                  @Summary:
11:                    This is the sysetm.h file generated using PIC24 / dsPIC33 / PIC32MM MCUs
12:                
13:                  @Description:
14:                    This header file provides implementations for driver APIs for all modules selected in the GUI.
15:                    Generation Information :
16:                        Product Revision  :  PIC24 / dsPIC33 / PIC32MM MCUs - 1.171.1
17:                        Device            :  dsPIC33CK256MP506
18:                    The generated drivers are tested against the following:
19:                        Compiler          :  XC16 v1.70
20:                        MPLAB             :  MPLAB X v5.50
21:                */
22:                
23:                /*
24:                    (c) 2020 Microchip Technology Inc. and its subsidiaries. You may use this
25:                    software and any derivatives exclusively with Microchip products.
26:                
27:                    THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
28:                    EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
29:                    WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
30:                    PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP PRODUCTS, COMBINATION
31:                    WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
32:                
33:                    IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
34:                    INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
35:                    WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
36:                    BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
37:                    FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
38:                    ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
39:                    THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
40:                
41:                    MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE
42:                    TERMS.
43:                */
44:                
45:                // Configuration bits: selected in the GUI
46:                
47:                // FSEC
48:                #pragma config BWRP = OFF    //Boot Segment Write-Protect bit->Boot Segment may be written
49:                #pragma config BSS = DISABLED    //Boot Segment Code-Protect Level bits->No Protection (other than BWRP)
50:                #pragma config BSEN = OFF    //Boot Segment Control bit->No Boot Segment
51:                #pragma config GWRP = OFF    //General Segment Write-Protect bit->General Segment may be written
52:                #pragma config GSS = DISABLED    //General Segment Code-Protect Level bits->No Protection (other than GWRP)
53:                #pragma config CWRP = OFF    //Configuration Segment Write-Protect bit->Configuration Segment may be written
54:                #pragma config CSS = DISABLED    //Configuration Segment Code-Protect Level bits->No Protection (other than CWRP)
55:                #pragma config AIVTDIS = OFF    //Alternate Interrupt Vector Table bit->Disabled AIVT
56:                
57:                // FBSLIM
58:                #pragma config BSLIM = 8191    //Boot Segment Flash Page Address Limit bits->8191
59:                
60:                // FOSCSEL
61:                #pragma config FNOSC = FRC    //Oscillator Source Selection->FRC
62:                #pragma config IESO = OFF    //Two-speed Oscillator Start-up Enable bit->Start up with user-selected oscillator source
63:                
64:                // FOSC
65:                #pragma config POSCMD = NONE    //Primary Oscillator Mode Select bits->Primary Oscillator disabled
66:                #pragma config OSCIOFNC = OFF    //OSC2 Pin Function bit->OSC2 is clock output
67:                #pragma config FCKSM = CSECMD    //Clock Switching Mode bits->Clock switching is enabled,Fail-safe Clock Monitor is disabled
68:                #pragma config PLLKEN = ON    //PLL Lock Status Control->PLL lock signal will be used to disable PLL clock output if lock is lost
69:                #pragma config XTCFG = G3    //XT Config->24-32 MHz crystals
70:                #pragma config XTBST = ENABLE    //XT Boost->Boost the kick-start
71:                
72:                // FWDT
73:                #pragma config RWDTPS = PS2147483648    //Run Mode Watchdog Timer Post Scaler select bits->1:2147483648
74:                #pragma config RCLKSEL = LPRC    //Watchdog Timer Clock Select bits->Always use LPRC
75:                #pragma config WINDIS = OFF    //Watchdog Timer Window Enable bit->Watchdog Timer in Window mode
76:                #pragma config WDTWIN = WIN25    //Watchdog Timer Window Select bits->WDT Window is 25% of WDT period
77:                #pragma config SWDTPS = PS2147483648    //Sleep Mode Watchdog Timer Post Scaler select bits->1:2147483648
78:                #pragma config FWDTEN = ON_SW    //Watchdog Timer Enable bit->WDT controlled via SW, use WDTCON.ON bit
79:                
80:                // FPOR
81:                #pragma config BISTDIS = DISABLED    //Memory BIST Feature Disable->mBIST on reset feature disabled
82:                
83:                // FICD
84:                #pragma config ICS = PGD2    //ICD Communication Channel Select bits->Communicate on PGC2 and PGD2
85:                #pragma config JTAGEN = OFF    //JTAG Enable bit->JTAG is disabled
86:                #pragma config NOBTSWP = DISABLED    //BOOTSWP instruction disable bit->BOOTSWP instruction is disabled
87:                
88:                // FDMTIVTL
89:                #pragma config DMTIVTL = 0    //Dead Man Timer Interval low word->0
90:                
91:                // FDMTIVTH
92:                #pragma config DMTIVTH = 0    //Dead Man Timer Interval high word->0
93:                
94:                // FDMTCNTL
95:                #pragma config DMTCNTL = 0    //Lower 16 bits of 32 bit DMT instruction count time-out value (0-0xFFFF)->0
96:                
97:                // FDMTCNTH
98:                #pragma config DMTCNTH = 0    //Upper 16 bits of 32 bit DMT instruction count time-out value (0-0xFFFF)->0
99:                
100:               // FDMT
101:               #pragma config DMTDIS = OFF    //Dead Man Timer Disable bit->Dead Man Timer is Disabled and can be enabled by software
102:               
103:               // FDEVOPT
104:               #pragma config ALTI2C1 = OFF    //Alternate I2C1 Pin bit->I2C1 mapped to SDA1/SCL1 pins
105:               #pragma config ALTI2C2 = OFF    //Alternate I2C2 Pin bit->I2C2 mapped to SDA2/SCL2 pins
106:               #pragma config ALTI2C3 = OFF    //Alternate I2C3 Pin bit->I2C3 mapped to SDA3/SCL3 pins
107:               #pragma config SMBEN = SMBUS    //SM Bus Enable->SMBus input threshold is enabled
108:               #pragma config SPI2PIN = PPS    //SPI2 Pin Select bit->SPI2 uses I/O remap (PPS) pins
109:               
110:               // FALTREG
111:               #pragma config CTXT1 = OFF    //Specifies Interrupt Priority Level (IPL) Associated to Alternate Working Register 1 bits->Not Assigned
112:               #pragma config CTXT2 = OFF    //Specifies Interrupt Priority Level (IPL) Associated to Alternate Working Register 2 bits->Not Assigned
113:               #pragma config CTXT3 = OFF    //Specifies Interrupt Priority Level (IPL) Associated to Alternate Working Register 3 bits->Not Assigned
114:               #pragma config CTXT4 = OFF    //Specifies Interrupt Priority Level (IPL) Associated to Alternate Working Register 4 bits->Not Assigned
115:               
116:               // FBTSEQ
117:               #pragma config BSEQ = 4095    //Relative value defining which partition will be active after device Reset; the partition containing a lower boot number will be active->4095
118:               #pragma config IBSEQ = 4095    //The one's complement of BSEQ; must be calculated by the user and written during device programming.->4095
119:               
120:               // FBOOT
121:               #pragma config BTMODE = SINGLE    //Device Boot Mode Configuration->Device is in Single Boot (legacy) mode
122:               
123:               #include "pin_manager.h"
124:               #include "clock.h"
125:               #include "system.h"
126:               #include "system_types.h"
127:               #include "uart2.h"
128:               #include "interrupt_manager.h"
129:               #include "traps.h"
130:               #include "uart1.h"
131:               #include "tmr1.h"
132:               
133:               void SYSTEM_Initialize(void)
134:               {
135:                   PIN_MANAGER_Initialize();
000CC2  07FF42     RCALL PIN_MANAGER_Initialize
136:                   CLOCK_Initialize();
000CC4  07FFAD     RCALL CLOCK_Initialize
137:                   INTERRUPT_Initialize();
000CC6  07FFDD     RCALL INTERRUPT_Initialize
138:                   UART2_Initialize();
000CC8  07FD7A     RCALL UART2_Initialize
139:                   UART1_Initialize();
000CCA  07FEFB     RCALL UART1_Initialize
140:                   TMR1_Initialize();
000CCC  07FF86     RCALL TMR1_Initialize
141:                   INTERRUPT_GlobalEnable();
000CCE  07FFF5     RCALL INTERRUPT_GlobalEnable
142:                   SYSTEM_CORCONModeOperatingSet(CORCON_MODE_PORVALUES);
000CD0  200200     MOV #0x20, W0
000CD2  07FFED     RCALL SYSTEM_CORCONModeOperatingSet
143:               }
000CD4  060000     RETURN
144:               
145:               /**
146:                End of File
147:               */
---  C:/Cust_Tests/CKAutoBaud/CKABaud081622.X/mcc_generated_files/reset.c  ------------------------------
1:                 /**
2:                   RESET Generated Driver File
3:                 
4:                   @Company
5:                     Microchip Technology Inc.
6:                 
7:                   @File Name
8:                     reset.c
9:                 
10:                  @Summary
11:                    This is the generated driver implementation file for the RESET driver using PIC24 / dsPIC33 / PIC32MM MCUs
12:                
13:                  @Description
14:                    This header file provides implementations for driver APIs for RESET.
15:                    Generation Information :
16:                        Product Revision  :  PIC24 / dsPIC33 / PIC32MM MCUs - 1.171.1
17:                        Device            :  dsPIC33CK256MP506
18:                    The generated drivers are tested against the following:
19:                        Compiler          :  XC16 v1.70
20:                        MPLAB             :  MPLAB X v5.50
21:                */
22:                
23:                /*
24:                    (c) 2020 Microchip Technology Inc. and its subsidiaries. You may use this
25:                    software and any derivatives exclusively with Microchip products.
26:                
27:                    THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
28:                    EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
29:                    WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
30:                    PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP PRODUCTS, COMBINATION
31:                    WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
32:                
33:                    IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
34:                    INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
35:                    WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
36:                    BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
37:                    FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
38:                    ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
39:                    THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
40:                
41:                    MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE
42:                    TERMS.
43:                */
44:                
45:                #include <stdbool.h>
46:                #include <stdint.h>
47:                #include "xc.h"
48:                #include "reset.h"
49:                
50:                /**
51:                 Section: Local Variables
52:                */
53:                
54:                /**
55:                 Section: Function prototypes
56:                */
57:                static bool RESET_CauseFromSoftware(uint16_t resetCause);
58:                static bool RESET_CauseFromWatchdogTimer(uint16_t resetCause);
59:                static bool RESET_CauseFromConfigurationMismatch(uint16_t resetCause);
60:                static bool RESET_CauseFromIllegalOpcode(uint16_t resetCause);
61:                static bool RESET_CauseFromExternal(uint16_t resetCause);
62:                static bool RESET_CauseFromTrap(uint16_t resetCause);
63:                static void RESET_CauseClear(RESET_MASKS resetFlagMask);
64:                
65:                uint16_t RESET_GetCause(void)
66:                {
67:                    return RCON;
000A68  807C00     MOV RCON, W0
68:                }
000A6A  060000     RETURN
69:                
70:                void __attribute__ ((weak)) RESET_CauseHandler(void)
71:                {
000A6C  781F88     MOV W8, [W15++]
72:                    uint16_t resetCause = RESET_GetCause();
000A6E  07FFFC     RCALL RESET_GetCause
000A70  780400     MOV W0, W8
73:                    if(RESET_CauseFromTrap(resetCause))
000A72  780008     MOV W8, W0
000A74  07FFE2     RCALL RESET_CauseFromTrap
000A76  E00400     CP0.B W0
000A78  320002     BRA Z, .L10
74:                    { 
75:                      RESET_CauseClear(RESET_MASK_TRAPR); 
000A7A  280000     MOV #0x8000, W0
000A7C  07FFF1     RCALL RESET_CauseClear
76:                      //Do something 
77:                    }
78:                    if(RESET_CauseFromIllegalOpcode(resetCause))
000A7E  780008     MOV W8, W0
000A80  07FFDE     RCALL RESET_CauseFromIllegalOpcode
000A82  E00400     CP0.B W0
000A84  320002     BRA Z, .L11
79:                    { 
80:                      RESET_CauseClear(RESET_MASK_IOPUWR); 
000A86  240000     MOV #0x4000, W0
000A88  07FFEB     RCALL RESET_CauseClear
81:                      //Do something 
82:                    }
83:                    if(RESET_CauseFromConfigurationMismatch(resetCause))
000A8A  780008     MOV W8, W0
000A8C  07FFDD     RCALL RESET_CauseFromConfigurationMismatch
000A8E  E00400     CP0.B W0
000A90  320002     BRA Z, .L12
84:                    { 
85:                      RESET_CauseClear(RESET_MASK_CM); 
000A92  202000     MOV #0x200, W0
000A94  07FFE5     RCALL RESET_CauseClear
86:                      //Do something 
87:                    }
88:                    if(RESET_CauseFromExternal(resetCause))
000A96  780008     MOV W8, W0
000A98  07FFDA     RCALL RESET_CauseFromExternal
000A9A  E00400     CP0.B W0
000A9C  320002     BRA Z, .L13
89:                    { 
90:                      RESET_CauseClear(RESET_MASK_EXTR); 
000A9E  200800     MOV #0x80, W0
000AA0  07FFDF     RCALL RESET_CauseClear
91:                      //Do something 
92:                    }
93:                    if(RESET_CauseFromSoftware(resetCause))
000AA2  780008     MOV W8, W0
000AA4  07FFD7     RCALL RESET_CauseFromSoftware
000AA6  E00400     CP0.B W0
000AA8  320002     BRA Z, .L14
94:                    { 
95:                      RESET_CauseClear(RESET_MASK_SWR); 
000AAA  200400     MOV #0x40, W0
000AAC  07FFD9     RCALL RESET_CauseClear
96:                      //Do something 
97:                    }
98:                    if(RESET_CauseFromWatchdogTimer(resetCause))
000AAE  780008     MOV W8, W0
000AB0  07FFD4     RCALL RESET_CauseFromWatchdogTimer
000AB2  E00400     CP0.B W0
000AB4  320002     BRA Z, .L9
99:                    { 
100:                     RESET_CauseClear(RESET_MASK_WDTO); 
000AB6  200100     MOV #0x10, W0
000AB8  07FFD3     RCALL RESET_CauseClear
101:                     //Do something 
102:                   }
103:               }
000ABA  78044F     MOV [--W15], W8
000ABC  060000     RETURN
104:               
105:               static bool RESET_CauseFromTrap(uint16_t resetCause)
000A3A  DE004F     LSR W0, #15, W0
106:               {
107:                   bool resetStatus = false;
108:                   if(resetCause & RESET_MASK_TRAPR)
109:                   { 
110:                     resetStatus = true; 
111:                   }
112:                   return resetStatus;
113:               }
000A3C  060000     RETURN
114:               
115:               static bool RESET_CauseFromIllegalOpcode(uint16_t resetCause)
000A3E  240001     MOV #0x4000, W1
000A40  600001     AND W0, W1, W0
000A42  EA0000     NEG W0, W0
000A44  DE004F     LSR W0, #15, W0
116:               {
117:                   bool resetStatus = false;
118:                   if(resetCause & RESET_MASK_IOPUWR)
119:                   { 
120:                     resetStatus = true; 
121:                   }
122:                   return resetStatus;
123:               }
000A46  060000     RETURN
124:               
125:               static bool RESET_CauseFromConfigurationMismatch(uint16_t resetCause)
000A48  0A8099     BFEXT #0x9, #0x1, W0, W0
000A4A  000000     NOP
126:               {
127:                   bool resetStatus = false;
128:                   if(resetCause & RESET_MASK_CM)
129:                   { 
130:                     resetStatus = true; 
131:                   }
132:                   return resetStatus;
133:               }
000A4C  060000     RETURN
134:               
135:               static bool RESET_CauseFromExternal(uint16_t resetCause)
000A4E  0A8077     BFEXT #0x7, #0x1, W0, W0
000A50  000000     NOP
136:               {
137:                   bool resetStatus = false;
138:                   if(resetCause & RESET_MASK_EXTR)
139:                   { 
140:                     resetStatus = true; 
141:                   }
142:                   return resetStatus;
143:               }
000A52  060000     RETURN
144:               
145:               static bool RESET_CauseFromSoftware(uint16_t resetCause)
000A54  0A8066     BFEXT #0x6, #0x1, W0, W0
000A56  000000     NOP
146:               {
147:                   bool resetStatus = false;
148:                   if(resetCause & RESET_MASK_SWR)
149:                   { 
150:                     resetStatus = true; 
151:                   }
152:                   return resetStatus;
153:               }
000A58  060000     RETURN
154:               
155:               static bool RESET_CauseFromWatchdogTimer(uint16_t resetCause)
000A5A  0A8044     BFEXT #0x4, #0x1, W0, W0
000A5C  000000     NOP
156:               {
157:                   bool resetStatus = false;
158:                   if(resetCause & RESET_MASK_WDTO)
159:                   { 
160:                     resetStatus = true;
161:                   }
162:                   return resetStatus;
163:               }
000A5E  060000     RETURN
164:               
165:               static void RESET_CauseClear(RESET_MASKS resetFlagMask)
166:               { 
167:                    RCON = RCON & (~resetFlagMask); 
000A60  EA8000     COM W0, W0
000A62  B60F80     AND RCON, WREG
000A64  887C00     MOV W0, RCON
168:               } 
000A66  060000     RETURN
169:               
170:               void RESET_CauseClearAll()
171:               { 
172:                   RCON = 0x00; 
000ABE  EF2F80     CLR RCON
173:               }
000AC0  060000     RETURN
174:               /**
175:                End of File
176:               */
---  C:/Cust_Tests/CKAutoBaud/CKABaud081622.X/mcc_generated_files/pin_manager.c  ------------------------
1:                 /**
2:                   PIN MANAGER Generated Driver File
3:                 
4:                   @Company:
5:                     Microchip Technology Inc.
6:                 
7:                   @File Name:
8:                     pin_manager.c
9:                 
10:                  @Summary:
11:                    This is the generated manager file for the PIC24 / dsPIC33 / PIC32MM MCUs device.  This manager
12:                    configures the pins direction, initial state, analog setting.
13:                    The peripheral pin select, PPS, configuration is also handled by this manager.
14:                
15:                  @Description:
16:                    This source file provides implementations for PIN MANAGER.
17:                    Generation Information :
18:                        Product Revision  :  PIC24 / dsPIC33 / PIC32MM MCUs - 1.171.1
19:                        Device            :  dsPIC33CK256MP506
20:                    The generated drivers are tested against the following:
21:                        Compiler          :  XC16 v1.70
22:                        MPLAB 	          :  MPLAB X v5.50
23:                */
24:                
25:                /*
26:                    (c) 2020 Microchip Technology Inc. and its subsidiaries. You may use this
27:                    software and any derivatives exclusively with Microchip products.
28:                
29:                    THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
30:                    EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
31:                    WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
32:                    PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP PRODUCTS, COMBINATION
33:                    WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
34:                
35:                    IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
36:                    INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
37:                    WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
38:                    BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
39:                    FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
40:                    ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
41:                    THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
42:                
43:                    MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE
44:                    TERMS.
45:                */
46:                
47:                
48:                /**
49:                    Section: Includes
50:                */
51:                
52:                #include <xc.h>
53:                #include <stdio.h>
54:                #include "pin_manager.h"
55:                
56:                /**
57:                 Section: Driver Interface Function Definitions
58:                */
59:                void PIN_MANAGER_Initialize (void)
60:                {
61:                    /****************************************************************************
62:                     * Setting the Output Latch SFR(s)
63:                     ***************************************************************************/
64:                    LATA = 0x0000;
000B48  EF2E06     CLR LATA
65:                    LATB = 0x0000;
000B4A  EF2E22     CLR LATB
66:                    LATC = 0x0900;
000B4C  209000     MOV #0x900, W0
000B4E  8871F0     MOV W0, LATC
67:                    LATD = 0x0000;
000B50  EF2E5A     CLR LATD
68:                
69:                    /****************************************************************************
70:                     * Setting the GPIO Direction SFR(s)
71:                     ***************************************************************************/
72:                    TRISA = 0x001F;
000B52  2001F0     MOV #0x1F, W0
000B54  887010     MOV W0, TRISA
73:                    TRISB = 0x3FFD;
000B56  23FFD1     MOV #0x3FFD, W1
000B58  8870F1     MOV W1, TRISB
74:                    TRISC = 0xE6FF;
000B5A  2E6FF1     MOV #0xE6FF, W1
000B5C  8871D1     MOV W1, TRISC
75:                    TRISD = 0xFFFF;
000B5E  EFAE56     SETM TRISD
76:                
77:                    /****************************************************************************
78:                     * Setting the Weak Pull Up and Weak Pull Down SFR(s)
79:                     ***************************************************************************/
80:                    CNPDA = 0x0000;
000B60  EF2E0C     CLR CNPDA
81:                    CNPDB = 0x0000;
000B62  EF2E28     CLR CNPDB
82:                    CNPDC = 0x0000;
000B64  EF2E44     CLR CNPDC
83:                    CNPDD = 0x0000;
000B66  EF2E60     CLR CNPDD
84:                    CNPUA = 0x0000;
000B68  EF2E0A     CLR CNPUA
85:                    CNPUB = 0x0000;
000B6A  EF2E26     CLR CNPUB
86:                    CNPUC = 0x0000;
000B6C  EF2E42     CLR CNPUC
87:                    CNPUD = 0x0000;
000B6E  EF2E5E     CLR CNPUD
88:                
89:                    /****************************************************************************
90:                     * Setting the Open Drain SFR(s)
91:                     ***************************************************************************/
92:                    ODCA = 0x0000;
000B70  EF2E08     CLR ODCA
93:                    ODCB = 0x0000;
000B72  EF2E24     CLR ODCB
94:                    ODCC = 0x0000;
000B74  EF2E40     CLR ODCC
95:                    ODCD = 0x0000;
000B76  EF2E5C     CLR ODCD
96:                
97:                    /****************************************************************************
98:                     * Setting the Analog/Digital Configuration SFR(s)
99:                     ***************************************************************************/
100:                   ANSELA = 0x001F;
000B78  887000     MOV W0, ANSELA
101:                   ANSELB = 0x0185;
000B7A  201850     MOV #0x185, W0
000B7C  8870E0     MOV W0, ANSELB
102:                   ANSELC = 0x00CF;
000B7E  200CF0     MOV #0xCF, W0
000B80  8871C0     MOV W0, ANSELC
103:                   ANSELD = 0x2C00;
000B82  22C000     MOV #0x2C00, W0
000B84  8872A0     MOV W0, ANSELD
104:                   
105:                   /****************************************************************************
106:                    * Set the PPS
107:                    ***************************************************************************/
108:                   __builtin_write_RPCON(0x0000); // unlock PPS
000B86  EB0000     CLR W0
000B88  200551     MOV #0x55, W1
000B8A  8846B1     MOV W1, NVMKEY
000B8C  200AA1     MOV #0xAA, W1
000B8E  8846B1     MOV W1, NVMKEY
000B90  886800     MOV W0, RPCON
109:               
110:                   RPINR19bits.U2RXR = 0x0029;    //RB9->UART2:U2RX
000B92  B3C290     MOV.B #0x29, W0
000B94  B7ED2A     MOV.B WREG, RPINR19
111:                   RPOR13bits.RP59R = 0x0001;    //RC11->UART1:U1TX
000B96  2C0FF0     MOV #0xC0FF, W0
000B98  B60D9A     AND RPOR13, WREG
000B9A  A08000     BSET W0, #8
000B9C  886CD0     MOV W0, RPOR13
112:                   RPINR18bits.U1RXR = 0x0049;    //RD9->UART1:U1RX
000B9E  B3C490     MOV.B #0x49, W0
000BA0  B7ED28     MOV.B WREG, RPINR18
113:                   RPOR12bits.RP56R = 0x0003;    //RC8->UART2:U2TX
000BA2  2FFC00     MOV #0xFFC0, W0
000BA4  B60D98     AND RPOR12, WREG
000BA6  B30030     IOR #0x3, W0
000BA8  886CC0     MOV W0, RPOR12
114:               
115:                   __builtin_write_RPCON(0x0800); // lock PPS
000BAA  208000     MOV #0x800, W0
000BAC  200551     MOV #0x55, W1
000BAE  8846B1     MOV W1, NVMKEY
000BB0  200AA1     MOV #0xAA, W1
000BB2  8846B1     MOV W1, NVMKEY
000BB4  886800     MOV W0, RPCON
116:               }
000BB6  060000     RETURN
117:               
---  C:/Cust_Tests/CKAutoBaud/CKABaud081622.X/mcc_generated_files/interrupt_manager.h  ------------------
1:                 /**
2:                   System Interrupts Generated Driver File 
3:                 
4:                   @Company:
5:                     Microchip Technology Inc.
6:                 
7:                   @File Name:
8:                     interrupt_manager.h
9:                 
10:                  @Summary:
11:                    This is the generated driver implementation file for setting up the
12:                    interrupts using PIC24 / dsPIC33 / PIC32MM MCUs
13:                
14:                  @Description:
15:                    This source file provides implementations for PIC24 / dsPIC33 / PIC32MM MCUs interrupts.
16:                    Generation Information : 
17:                        Product Revision  :  PIC24 / dsPIC33 / PIC32MM MCUs - 1.171.1
18:                        Device            :  dsPIC33CK256MP506
19:                    The generated drivers are tested against the following:
20:                        Compiler          :  XC16 v1.70
21:                        MPLAB             :  MPLAB X v5.50
22:                */
23:                /*
24:                    (c) 2020 Microchip Technology Inc. and its subsidiaries. You may use this
25:                    software and any derivatives exclusively with Microchip products.
26:                
27:                    THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
28:                    EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
29:                    WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
30:                    PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP PRODUCTS, COMBINATION
31:                    WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
32:                
33:                    IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
34:                    INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
35:                    WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
36:                    BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
37:                    FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
38:                    ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
39:                    THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
40:                
41:                    MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE
42:                    TERMS.
43:                */
44:                
45:                #ifndef _INTERRUPT_MANAGER_H
46:                #define _INTERRUPT_MANAGER_H
47:                
48:                /**
49:                  @Summary
50:                    Initializes the interrupt priorities of the dsPIC33CK256MP506
51:                
52:                  @Description
53:                    This routine sets the interrupt priorities of the modules that have been configured
54:                    for the dsPIC33CK256MP506
55:                
56:                  @Preconditions
57:                    None.
58:                
59:                  @Returns
60:                    None.
61:                
62:                  @Param
63:                    None.
64:                
65:                  @Example
66:                    <code>
67:                    void SYSTEM_Initialize(void)
68:                    {
69:                        // Other initializers are called from this function
70:                        INTERRUPT_Initialize ();
71:                    }
72:                    </code>
73:                
74:                */
75:                void INTERRUPT_Initialize(void);
76:                
77:                /**
78:                  @Summary
79:                    Enables global interrupts of the dsPIC33CK256MP506
80:                
81:                  @Description
82:                    This routine enables the global interrupt bit for the dsPIC33CK256MP506
83:                
84:                  @Preconditions
85:                    None.
86:                
87:                  @Returns
88:                    None.
89:                
90:                  @Param
91:                    None.
92:                
93:                  @Example
94:                    <code>
95:                    void SYSTEM_Initialize(void)
96:                    {
97:                        // Other initializers are called from this function
98:                        INTERRUPT_GlobalEnable ();
99:                    }
100:                   </code>
101:               
102:               */
103:               inline static void INTERRUPT_GlobalEnable(void)
104:               {
105:                   __builtin_enable_interrupts();
000CBA  A8E8C3     BSET 0x8C3, #7
000CBC  000000     NOP
000CBE  000000     NOP
106:               }
000CC0  060000     RETURN
107:               
108:               /**
109:                 @Summary
110:                   Disables global interrupts of the dsPIC33CK256MP506
111:               
112:                 @Description
113:                   This routine disables the global interrupt bit for the dsPIC33CK256MP506
114:               
115:                 @Preconditions
116:                   None.
117:               
118:                 @Returns
119:                   None.
120:               
121:                 @Param
122:                   None.
123:               
124:                 @Example
125:                   <code>
126:                   void SYSTEM_Initialize(void)
127:                   {
128:                       // Other initializers are called from this function
129:                       INTERRUPT_GlobalDisable ();
130:                   }
131:                   </code>
132:               
133:               */
134:               inline static void INTERRUPT_GlobalDisable(void)
135:               {
136:                   __builtin_disable_interrupts();
137:               }
138:               
139:               /**
140:                 @Summary
141:                   Returns the interrupt vector number of the interrupt which is pending.
142:               
143:                 @Description
144:                   This routine returns the interrupt vector number of the interrupt which is pending.
145:               
146:                 @Preconditions
147:                   None.
148:               
149:                 @Returns
150:                   None.
151:               
152:                 @Param
153:                   None.
154:               
155:                 @Example
156:                   <code>
157:                       uint16_t ivrNum;
158:                       ivrNum = INTERRUPT_VectorNumberGet();
159:                   </code>
160:               
161:               */
162:               inline static uint16_t INTERRUPT_VectorNumberGet(void)
163:               {
164:                   return _VECNUM; 
165:               }
166:               
167:               #endif
---  C:/Cust_Tests/CKAutoBaud/CKABaud081622.X/mcc_generated_files/interrupt_manager.c  ------------------
1:                 /**
2:                   System Interrupts Generated Driver File 
3:                 
4:                   @Company:
5:                     Microchip Technology Inc.
6:                 
7:                   @File Name:
8:                     interrupt_manager.h
9:                 
10:                  @Summary:
11:                    This is the generated driver implementation file for setting up the
12:                    interrupts using PIC24 / dsPIC33 / PIC32MM MCUs
13:                
14:                  @Description:
15:                    This source file provides implementations for PIC24 / dsPIC33 / PIC32MM MCUs interrupts.
16:                    Generation Information : 
17:                        Product Revision  :  PIC24 / dsPIC33 / PIC32MM MCUs - 1.171.1
18:                        Device            :  dsPIC33CK256MP506
19:                    The generated drivers are tested against the following:
20:                        Compiler          :  XC16 v1.70
21:                        MPLAB             :  MPLAB X v5.50
22:                */
23:                /*
24:                    (c) 2020 Microchip Technology Inc. and its subsidiaries. You may use this
25:                    software and any derivatives exclusively with Microchip products.
26:                
27:                    THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
28:                    EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
29:                    WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
30:                    PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP PRODUCTS, COMBINATION
31:                    WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
32:                
33:                    IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
34:                    INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
35:                    WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
36:                    BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
37:                    FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
38:                    ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
39:                    THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
40:                
41:                    MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE
42:                    TERMS.
43:                */
44:                
45:                /**
46:                    Section: Includes
47:                */
48:                #include <xc.h>
49:                
50:                /**
51:                    void INTERRUPT_Initialize (void)
52:                */
53:                void INTERRUPT_Initialize (void)
54:                {
55:                    //    UEVTI: UART2 Event
56:                    //    Priority: 1
57:                        IPC47bits.U2EVTIP = 1;
000C82  2F8FF0     MOV #0xF8FF, W0
000C84  8044F2     MOV IPC47, W2
000C86  600082     AND W0, W2, W1
000C88  A08001     BSET W1, #8
000C8A  8844F1     MOV W1, IPC47
58:                    //    UTXI: UART2 TX
59:                    //    Priority: 1
60:                        IPC7bits.U2TXIP = 1;
000C8C  2FFF81     MOV #0xFFF8, W1
000C8E  804272     MOV IPC7, W2
000C90  608082     AND W1, W2, W1
000C92  A00001     BSET W1, #0
000C94  884271     MOV W1, IPC7
61:                    //    UEI: UART2 Error
62:                    //    Priority: 1
63:                        IPC12bits.U2EIP = 1;
000C96  B60858     AND IPC12, WREG
000C98  A08000     BSET W0, #8
000C9A  8842C0     MOV W0, IPC12
64:                    //    URXI: UART2 RX
65:                    //    Priority: 1
66:                        IPC6bits.U2RXIP = 1;
000C9C  28FFF0     MOV #0x8FFF, W0
000C9E  B6084C     AND IPC6, WREG
000CA0  A0C000     BSET W0, #12
000CA2  884260     MOV W0, IPC6
67:                    //    TI: Timer 1
68:                    //    Priority: 1
69:                        IPC0bits.T1IP = 1;
000CA4  2FF8F0     MOV #0xFF8F, W0
000CA6  B60840     AND IPC0, WREG
000CA8  A04000     BSET W0, #4
000CAA  884200     MOV W0, IPC0
70:                }
000CAC  060000     RETURN
---  C:/Cust_Tests/CKAutoBaud/CKABaud081622.X/mcc_generated_files/clock.c  ------------------------------
1:                 /**
2:                   @Generated PIC24 / dsPIC33 / PIC32MM MCUs Source File
3:                 
4:                   @Company:
5:                     Microchip Technology Inc.
6:                 
7:                   @File Name:
8:                     clock.c
9:                 
10:                  @Summary:
11:                    This is the clock.c file generated using PIC24 / dsPIC33 / PIC32MM MCUs
12:                
13:                  @Description:
14:                    This header file provides implementations for driver APIs for all modules selected in the GUI.
15:                    Generation Information :
16:                        Product Revision  :  PIC24 / dsPIC33 / PIC32MM MCUs - 1.171.1
17:                        Device            :  dsPIC33CK256MP506
18:                    The generated drivers are tested against the following:
19:                        Compiler          :  XC16 v1.70
20:                        MPLAB             :  MPLAB X v5.50
21:                */
22:                
23:                /*
24:                    (c) 2020 Microchip Technology Inc. and its subsidiaries. You may use this
25:                    software and any derivatives exclusively with Microchip products.
26:                
27:                    THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
28:                    EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
29:                    WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
30:                    PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP PRODUCTS, COMBINATION
31:                    WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
32:                
33:                    IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
34:                    INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
35:                    WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
36:                    BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
37:                    FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
38:                    ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
39:                    THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
40:                
41:                    MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE
42:                    TERMS.
43:                */
44:                
45:                #include <stdint.h>
46:                #include "xc.h"
47:                #include "clock.h"
48:                
49:                void CLOCK_Initialize(void)
50:                {
51:                    // FRCDIV FRC/1; PLLPRE 1; DOZE 1:8; DOZEN disabled; ROI disabled; 
52:                    CLKDIV = 0x3001;
000C20  230010     MOV #0x3001, W0
000C22  887C30     MOV W0, CLKDIV
53:                    // PLLFBDIV 200; 
54:                    PLLFBD = 0xC8;
000C24  200C80     MOV #0xC8, W0
000C26  887C40     MOV W0, PLLFBD
55:                    // TUN Center frequency; 
56:                    OSCTUN = 0x00;
000C28  EF2F8C     CLR OSCTUN
57:                    // POST1DIV 1:2; VCODIV FVCO/4; POST2DIV 1:2; 
58:                    PLLDIV = 0x22;
000C2A  200220     MOV #0x22, W0
000C2C  887C50     MOV W0, PLLDIV
59:                    // APLLEN enabled; FRCSEL FRC; APLLPRE 1:1; 
60:                    ACLKCON1 = 0x8101;
000C2E  281010     MOV #0x8101, W0
000C30  887C70     MOV W0, ACLKCON1
61:                    // APLLFBDIV 125; 
62:                    APLLFBD1 = 0x7D;
000C32  2007D0     MOV #0x7D, W0
000C34  887C80     MOV W0, APLLFBD1
63:                    // APOST1DIV 1:2; APOST2DIV 1:1; AVCODIV FVCO/4; 
64:                    APLLDIV1 = 0x21;
000C36  200210     MOV #0x21, W0
000C38  887C90     MOV W0, APLLDIV1
65:                    // CANCLKEN disabled; CANCLKSEL No Clock Selected; CANCLKDIV Divide by 1; 
66:                    CANCLKCON = 0x00;
000C3A  EF2F9A     CLR CANCLKCON
67:                    // ROEN disabled; ROSWEN disabled; ROSLP disabled; ROSEL FOSC; ROOUT disabled; ROSIDL disabled; 
68:                    REFOCONL = 0x00;
000C3C  EF2FB8     CLR REFOCONL
69:                    // RODIV 0; 
70:                    REFOCONH = 0x00;
000C3E  EF2FBA     CLR REFOCONH
71:                    // ROTRIM 0; 
72:                    REFOTRIMH = 0x00;
000C40  EF2FBE     CLR REFOTRIMH
73:                    // IOLOCK disabled; 
74:                    RPCON = 0x00;
000C42  EF2D00     CLR RPCON
75:                    // PMDLOCK disabled; 
76:                    PMDCON = 0x00;
000C44  EF2FA0     CLR PMDCON
77:                    // ADC1MD enabled; T1MD enabled; U2MD enabled; U1MD enabled; SPI2MD enabled; SPI1MD enabled; QEI1MD enabled; C1MD enabled; PWMMD enabled; I2C1MD enabled; 
78:                    PMD1 = 0x00;
000C46  EF2FA4     CLR PMD1
79:                    // CCP2MD enabled; CCP1MD enabled; CCP4MD enabled; CCP3MD enabled; CCP7MD enabled; CCP8MD enabled; CCP5MD enabled; CCP6MD enabled; CCP9MD enabled; 
80:                    PMD2 = 0x00;
000C48  EF2FA6     CLR PMD2
81:                    // I2C3MD enabled; PMPMD enabled; U3MD enabled; QEI2MD enabled; CRCMD enabled; I2C2MD enabled; 
82:                    PMD3 = 0x00;
000C4A  EF2FA8     CLR PMD3
83:                    // REFOMD enabled; 
84:                    PMD4 = 0x00;
000C4C  EF2FAA     CLR PMD4
85:                    // DMA1MD enabled; SPI3MD enabled; DMA2MD enabled; DMA3MD enabled; DMA0MD enabled; 
86:                    PMD6 = 0x00;
000C4E  EF2FAE     CLR PMD6
87:                    // CMP3MD enabled; PTGMD enabled; CMP1MD enabled; CMP2MD enabled; 
88:                    PMD7 = 0x00;
000C50  EF2FB0     CLR PMD7
89:                    // DMTMD enabled; CLC3MD enabled; OPAMPMD enabled; BIASMD enabled; CLC4MD enabled; SENT2MD enabled; SENT1MD enabled; CLC1MD enabled; CLC2MD enabled; 
90:                    PMD8 = 0x00;
000C52  EF2FB2     CLR PMD8
91:                    // CF no clock failure; NOSC FRCPLL; CLKLOCK unlocked; OSWEN Switch is Complete; 
92:                    __builtin_write_OSCCONH((uint8_t) (0x01));
000C54  200010     MOV #0x1, W0
000C56  2009A2     MOV #0x9A, W2
000C58  200781     MOV #0x78, W1
000C5A  20F853     MOV #0xF85, W3
000C5C  784981     MOV.B W1, [W3]
000C5E  784982     MOV.B W2, [W3]
000C60  784980     MOV.B W0, [W3]
93:                    __builtin_write_OSCCONL((uint8_t) (0x01));
000C62  200572     MOV #0x57, W2
000C64  200461     MOV #0x46, W1
000C66  20F843     MOV #0xF84, W3
000C68  784981     MOV.B W1, [W3]
000C6A  784982     MOV.B W2, [W3]
000C6C  784980     MOV.B W0, [W3]
94:                    // Wait for Clock switch to occur
95:                    while (OSCCONbits.OSWEN != 0);
000C6E  AB0F84     BTST OSCCON, #0
000C70  3AFFFE     BRA NZ, .L2
96:                    while (OSCCONbits.LOCK != 1);
000C72  200201     MOV #0x20, W1
000C74  807C22     MOV OSCCON, W2
000C76  608002     AND W1, W2, W0
000C78  32FFFD     BRA Z, .L4
97:                }
000C7A  060000     RETURN
98:                
99:                bool CLOCK_AuxPllLockStatusGet()
100:               {
101:                   return ACLKCON1bits.APLLCK;
000C7C  0AA0EE     BFEXT #0xe, #0x1, ACLKCON1, W0
000C7E  000F8E     NOP
102:               }
000C80  060000     RETURN
---  C:/Cust_Tests/CKAutoBaud/CKABaud081622.X/main.c  ---------------------------------------------------
1:                 /**
2:                   Generated main.c file from MPLAB Code Configurator
3:                 
4:                   @Company
5:                     Microchip Technology Inc.
6:                 
7:                   @File Name
8:                     main.c
9:                 
10:                  @Summary
11:                    This is the generated main.c using PIC24 / dsPIC33 / PIC32MM MCUs.
12:                
13:                  @Description
14:                    This source file provides main entry point for system initialization and application code development.
15:                    Generation Information :
16:                        Product Revision  :  PIC24 / dsPIC33 / PIC32MM MCUs - 1.171.1
17:                        Device            :  dsPIC33CK256MP506
18:                    The generated drivers are tested against the following:
19:                        Compiler          :  XC16 v1.70
20:                        MPLAB 	          :  MPLAB X v5.50
21:                */
22:                
23:                /*
24:                    (c) 2020 Microchip Technology Inc. and its subsidiaries. You may use this
25:                    software and any derivatives exclusively with Microchip products.
26:                
27:                    THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
28:                    EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
29:                    WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
30:                    PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP PRODUCTS, COMBINATION
31:                    WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.
32:                
33:                    IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
34:                    INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
35:                    WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
36:                    BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
37:                    FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
38:                    ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
39:                    THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.
40:                
41:                    MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE
42:                    TERMS.
43:                */
44:                
45:                /**
46:                  Section: Included Files
47:                */
48:                #include "mcc_generated_files/system.h"
49:                #include "mcc_generated_files/pin_manager.h"
50:                #include "mcc_generated_files/tmr1.h"
51:                #include "mcc_generated_files/uart1.h"
52:                #include "mcc_generated_files/uart2.h"
53:                #ifndef FCY
54:                #define FCY     (_XTAL_FREQ/2)
55:                #endif
56:                
57:                #include <libpic30.h> 
58:                
59:                void send_break(uint16_t);
60:                /*
61:                                         Main application
62:                 */
63:                int main(void)
64:                {
0009BE  BE9F88     MOV.D W8, [W15++]
65:                
66:                
67:                    // initialize the device
68:                    SYSTEM_Initialize();
0009C0  070180     RCALL SYSTEM_Initialize
69:                    U2MODEbits.RXBIMD = 1;  //break character would set after 11 low before TX rising up
0009C2  A86261     BSET 0x261, #3
70:                 //   U2MODEbits.RXBIMD = 0;  //break character would set after 11 low after TX rising up
71:                    asm("mac w4*w5, A, [w8]+=2, w4, [w10]+=2, w5");
0009C4  C00446     MAC W4*W5, A, [W8]+=2, W4, [W10]+=2, W5
72:                    while (1)
73:                    {
74:                        // Add your application code
75:                        TP45_SetHigh();
0009CA  A8CE23     BSET 0xE23, #6
76:                    //    __delay_us(500); //for testing
77:                        TP45_SetLow();
0009CC  A9CE23     BCLR 0xE23, #6
78:                    //    U1MODEbits.UTXBRK = 1;  //send AUTO break
79:                        while (!U1STAbits.TRMT); //wait for buffer is empty
0009C6  200808     MOV #0x80, W8
0009CE  8011E1     MOV U1STA, W1
0009D0  640001     AND W8, W1, W0
0009D2  32FFFD     BRA Z, .L5
80:                        send_break(112);            //send manual break
0009D4  200700     MOV #0x70, W0
0009D6  07FFE2     RCALL send_break
81:                        UART1_Write(0x55);       //Send break and 0x0
0009D8  B3C550     MOV.B #0x55, W0
0009DA  070090     RCALL UART1_Write
82:                    //     __delay_us(500); //for testing
83:                        while (U2MODEbits.ABAUD==1){
0009C8  200409     MOV #0x40, W9
0009DC  801302     MOV U2MODE, W2
0009DE  648002     AND W9, W2, W0
0009E0  32000A     BRA Z, .L6
0009F0  801301     MOV U2MODE, W1
0009F2  648001     AND W9, W1, W0
0009F4  3AFFF6     BRA NZ, .L13
84:                            _LATC12 = U2MODEbits.ABAUD;
0009E2  0AA066     BFEXT #0x6, #0x1, U2MODE, W0
0009E4  000260     NOP
0009E6  DD004C     SL W0, #12, W0
0009E8  8071F1     MOV LATC, W1
0009EA  A1C001     BCLR W1, #12
0009EC  700081     IOR W0, W1, W1
0009EE  8871F1     MOV W1, LATC
85:                        };
86:                        _LATC12 = U2MODEbits.ABAUD;
0009F6  0AA066     BFEXT #0x6, #0x1, U2MODE, W0
0009F8  000260     NOP
0009FA  DD004C     SL W0, #12, W0
0009FC  8071F1     MOV LATC, W1
0009FE  A1C001     BCLR W1, #12
000A00  700081     IOR W0, W1, W1
000A02  8871F1     MOV W1, LATC
87:                     //   U2MODEbits.UARTEN = 0;
88:                     //   U2MODEbits.UARTEN = 1;
89:                        
90:                        while (U1MODEbits.UTXBRK);  //waiting for break complete (not use TRMT because of errata)
000A04  201001     MOV #0x100, W1
000A06  8011C2     MOV U1MODE, W2
000A08  608002     AND W1, W2, W0
000A0A  3AFFFD     BRA NZ, .L8
91:                        UART1_Write(0x50);   
000A0C  B3C500     MOV.B #0x50, W0
000A0E  070076     RCALL UART1_Write
92:                        UART1_Write(0x61);   
000A10  B3C610     MOV.B #0x61, W0
000A12  070074     RCALL UART1_Write
93:                        UART1_Write(0x75);   
000A14  B3C750     MOV.B #0x75, W0
000A16  070072     RCALL UART1_Write
94:                        UART1_Write(0x6C);   
000A18  B3C6C0     MOV.B #0x6C, W0
000A1A  070070     RCALL UART1_Write
95:                        while (!U1STAbits.TRMT); //wait for buffer is empty
000A1C  8011E1     MOV U1STA, W1
000A1E  640001     AND W8, W1, W0
000A20  32FFFD     BRA Z, .L9
96:                        U1MODEbits.UARTEN = 0;// switch off before clock change
000A22  A9E239     BCLR 0x239, #7
97:                        if (U1BRG != 0x1B1) U1BRG = 0x1B1;
000A24  201B10     MOV #0x1B1, W0
000A26  E30240     CP U1BRG
000A28  320002     BRA Z, .L10
000A2A  881200     MOV W0, U1BRG
000A2C  370002     BRA .L11
98:                        else U1BRG = 0xD8;
000A2E  200D80     MOV #0xD8, W0
000A30  881200     MOV W0, U1BRG
99:                        U1MODEbits.UARTEN = 1;
000A32  A8E239     BSET 0x239, #7
100:                 //       __delay_ms(1); //for testing
101:                        UART1_Write(0x66);  
000A34  B3C660     MOV.B #0x66, W0
000A36  070062     RCALL UART1_Write
102:                   }
000A38  37FFC8     BRA .L12
103:                   return 1; 
104:               }
105:               
106:               void UART2_Receive_CallBack(void)
107:               {
108:                   uint16_t temp;
109:                   Nop();
000986  000000     NOP
110:                   Nop();
000988  000000     NOP
111:                   TP47_SetHigh();
00098A  A8EE23     BSET 0xE23, #7
112:                   TP47_SetLow();
00098C  A9EE23     BCLR 0xE23, #7
113:                   if ((U1STAbits.OERR == 1))
00098E  AB223C     BTST U1STA, #1
000990  320001     BRA Z, .L2
114:                   {
115:                       U1STAbits.OERR = 0;
000992  A9223C     BCLR U1STA, #1
116:                   }
117:                   
118:                   temp = U1RXREG;
000994  801220     MOV U1RXREG, W0
119:                   Nop();
000996  000000     NOP
120:                   Nop();
000998  000000     NOP
121:               }
00099A  060000     RETURN
122:               
123:               void send_break(uint16_t usec){
124:                   U1MODEbits.BRKOVR = 1;
00099C  A82239     BSET 0x239, #1
125:                 //  U1MODEHbits.UTXINV = 1;
126:                   __delay_us(usec);
00099E  EB0080     CLR W1
0009A0  B81160     MUL.UU W2, #0x0, W2
0009A2  2E1004     MOV #0xE100, W4
0009A4  205F55     MOV #0x5F5, W5
0009A6  B83360     MUL.UU W6, #0x0, W6
0009A8  07FE92     RCALL ___muldi3
0009AA  242404     MOV #0x4240, W4
0009AC  2000F5     MOV #0xF, W5
0009AE  B83360     MUL.UU W6, #0x0, W6
0009B0  07FE25     RCALL ___udivdi3
0009B2  0701A5     RCALL ___delay32
127:                 //  U1MODEHbits.UTXINV = 0;
128:                   U1MODEbits.BRKOVR = 0;
0009B4  A92239     BCLR 0x239, #1
129:                   __delay_us(10);
0009B6  203E80     MOV #0x3E8, W0
0009B8  200001     MOV #0x0, W1
0009BA  0701A1     RCALL ___delay32
130:               }
0009BC  060000     RETURN
131:               /**
132:                End of File
133:               */
134:               
---  /home/xc16/release-builds/build_20220124/src/libm/src/umuldi3.s  -----------------------------------
000720  BE9F88     MOV.D W8, [W15++]
000722  BE9F8A     MOV.D W10, [W15++]
000724  BE9F8C     MOV.D W12, [W15++]
000726  B80404     MUL.UU W0, W4, W8
000728  B80605     MUL.UU W0, W5, W12
00072A  460489     ADD W12, W9, W9
00072C  4E8560     ADDC W13, #0x0, W10
00072E  B80606     MUL.UU W0, W6, W12
000730  46050A     ADD W12, W10, W10
000732  4E85E0     ADDC W13, #0x0, W11
000734  B80607     MUL.UU W0, W7, W12
000736  46058B     ADD W12, W11, W11
000738  B80E04     MUL.UU W1, W4, W12
00073A  460489     ADD W12, W9, W9
00073C  4E850A     ADDC W13, W10, W10
00073E  4D85E0     ADDC W11, #0x0, W11
000740  B80E05     MUL.UU W1, W5, W12
000742  46050A     ADD W12, W10, W10
000744  4E858B     ADDC W13, W11, W11
000746  B80E06     MUL.UU W1, W6, W12
000748  46058B     ADD W12, W11, W11
00074A  B81604     MUL.UU W2, W4, W12
00074C  46050A     ADD W12, W10, W10
00074E  4E858B     ADDC W13, W11, W11
000750  B81605     MUL.UU W2, W5, W12
000752  46058B     ADD W12, W11, W11
000754  B81E04     MUL.UU W3, W4, W12
000756  46058B     ADD W12, W11, W11
000758  BE0008     MOV.D W8, W0
00075A  BE010A     MOV.D W10, W2
00075C  BE064F     MOV.D [--W15], W12
00075E  BE054F     MOV.D [--W15], W10
000760  BE044F     MOV.D [--W15], W8
000762  060000     RETURN
